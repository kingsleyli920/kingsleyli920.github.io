<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>es6_summary_2</title>
      <link href="/en/2020/01/28/es6_summary_2/"/>
      <url>/en/2020/01/28/es6_summary_2/</url>
      
        <content type="html"><![CDATA[<center> <h1>ES6 Summary #2</h1> </center><center> <h2> <font color="lightgray">Asynchronous and synchronous</font> </h2> </center><h3 id="Asynchronous-and-synchronous-are-a-message-notification-mechanism"><a href="#Asynchronous-and-synchronous-are-a-message-notification-mechanism" class="headerlink" title="*Asynchronous and synchronous are a message notification mechanism.*"></a><strong>*<u>Asynchronous and synchronous are a message notification mechanism.</u>*</strong></h3><h2 id="What-is-Asynchronous？"><a href="#What-is-Asynchronous？" class="headerlink" title="What is Asynchronous？"></a>What is Asynchronous？</h2><h3 id="Asynchronous-non-blocking："><a href="#Asynchronous-non-blocking：" class="headerlink" title="Asynchronous non-blocking："></a>Asynchronous non-blocking：</h3><pre><code>For example: A calls B, while B processes, A continues to execute. The processing of B ends, the result is returned, and A is executed again with the result of B. A does not have to wait for the end of B's execution during this period.</code></pre><h3 id="Synchronous-blocking："><a href="#Synchronous-blocking：" class="headerlink" title="Synchronous blocking："></a>Synchronous blocking：</h3><pre><code>For example: A calls B, and B returns the result to A after processing, and A continues to execute. A waits for the end of B's execution during this period. The execution of normal code is performed line by line, which is the synchronization mechanism.</code></pre><h3 id="The-most-basic-way-to-achieve-asynchronous-Using-timers"><a href="#The-most-basic-way-to-achieve-asynchronous-Using-timers" class="headerlink" title="The most basic way to achieve asynchronous: Using timers"></a>The most basic way to achieve asynchronous: <strong><em>Using timers</em></strong></h3><pre><code>function move(ele, dir, dist) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    clearInterval(ele.timer);    console.log("start moving...");    ele.timer = setInterval(() =&gt; {       if (Math.abs(curPos - dist) &lt;= 0) {            clearInterval(ele.timer);            console.log("finish moving...");       } else {            curPos += speed;            ele.style[dir] = curPos + "px";       }    }, 20);    console.log("printing....");}let box = document.querySelector("#box");move(box, "left", 100);</code></pre><p>The result is：</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/code-result1.gif" alt="Code Result"></p><p>The printing result is：</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/code-result2.png" alt="Code Printing Result"></p><p>It can be seen from the results that “printing…” is printed before the end of the block movement, and it is not executed sequentially as in a regular program. This is the most basic asynchronous implementation.</p><h3 id="Need-more-operation-after-asynchronous-funtion-end"><a href="#Need-more-operation-after-asynchronous-funtion-end" class="headerlink" title="Need more operation after asynchronous funtion end?"></a>Need more operation after asynchronous funtion end?</h3><p>There must be many solutions, but I think the better method is the callback function method, modify the above code：</p><pre><code>function move(ele, dir, dist, callback) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    clearInterval(ele.timer);    console.log("start moving...");    ele.timer = setInterval(() =&gt; {       if (Math.abs(curPos - dist) &lt;= 0) {            clearInterval(ele.timer);            console.log("finish moving...");            callback &amp;&amp; callback(); // ===&gt;First determine whether there is a callback, if it exists, then execute       } else {            curPos += speed;            ele.style[dir] = curPos + "px";       }    }, 20);    console.log("printing....");}let box = document.querySelector("#box");move(box, "left", 100, () =&gt; {    console.log("Run callback function");});</code></pre><p>The result is：</p><pre><code>start moving...printing....finish moving...Run callback function</code></pre><p>This can well solve the problems that require asynchronous results or need to execute some code after asynchronous execution.</p><h3 id="This-implementation-of-asynchronous-and-callback-issues-Callback-Hell"><a href="#This-implementation-of-asynchronous-and-callback-issues-Callback-Hell" class="headerlink" title="This implementation of asynchronous and callback issues: Callback Hell"></a>This implementation of asynchronous and callback issues: <strong><em>Callback Hell</em></strong></h3><p>The Callback Hell is to call call back function multiple times, resulting in too many layers, as follows:</p><pre><code>move(box, "left", 100,() =&gt; {    move(box, "top", 100,() =&gt; {        move(box, "left", -100,() =&gt; {            move(box, "top", -100,() =&gt; {                console.log("finish...");            });        });    });});</code></pre><p>The layer of above code is too deep, which is not conducive to code reuse, maintainability, and readability.</p><h2 id="Callback-Hell-Solution"><a href="#Callback-Hell-Solution" class="headerlink" title="Callback Hell Solution"></a>Callback Hell Solution</h2><p>There are three solutions, namely using <strong>Promise</strong>, using <strong>Async and Await</strong>, and using <strong>Generator</strong> function. I will talk about the Promise.</p><h3 id="Promise-concept-and-usage"><a href="#Promise-concept-and-usage" class="headerlink" title="Promise concept and usage"></a>Promise concept and usage</h3><p><strong><em>Promises do not solve the asynchronous problem itself, but solve the asynchronous writing problem, making asynchronous writing clearly.</em></strong></p><p>Let’s talk about promises first. In MDN, promises are defined as follows:</p><pre><code>The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.[1]</code></pre><p>Promise has three states: <b> Pending (waiting for asynchronous process execution to complete); Fulfilled or Resolved (successful); Rejected (failed) &lt;/ b&gt;.<br>The result of the asynchronous operation determines the current state, and other content cannot interfere with the Promise state. In addition, if the status of a Promise changes, it will not change again. For example, if you change from a Pending turn to Rejected, state will not return to Pending or become Fulfilled again. [2]</b></p><p>The following shows a simple use of a Promise:</p><pre><code>let p = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            console.log(p);            resolve();        }, 2000);     });    p.then(() =&gt; {        console.log(p);        console.log("then....");    }); </code></pre><p>The “then” method is equivalent to the callback function. According to the above code, it can be found that a function is passed after the Promise is created. The parameters of the function are two functions - Resolve and Reject, corresponding to Rejected and Resolved (Fulfilled) States. Now you can see at a glance. If the asynchronous execution is successful, you call “resolve()”, otherwise “reject()”. The above results are:</p><p>After the program runs for two seconds, it prints the following：</p><pre><code>Promise {&lt;pending&gt;}Promise {&lt;resolved&gt;: undefined}then....</code></pre><p>It can be seen that if the asynchronous execution is successful and the Resolve function is called, the program will execute down to “then”, and from the two printed “p”s, we can see that the status of the Promise changes from Pending to Resolved.</p><h4 id="So-how-do-you-use-asynchronous-results"><a href="#So-how-do-you-use-asynchronous-results" class="headerlink" title="So how do you use asynchronous results?"></a>So how do you use asynchronous results?</h4><p>Many times, the results produced by asynchronous are what we will use later, so if we use Promise to optimize asynchronous writing, like above, how do we use asynchronous results?</p><p>In fact, the answer already appears in the above code. The second line of the above code results, There is an “undefined” value after “resolved”. This place is used to store asynchronous results. The code can be changed as follows:</p><pre><code>let p = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            console.log(p);            resolve("parameters..."); // =======》Here you can pass parameters when executing resolve.        }, 2000);  }); p.then((res) =&gt; { // ======》You can pass a parameter here, such asres        console.log(p);        console.log(res);                 console.log("then...."); });</code></pre><p>The results are：</p><pre><code>Promise {&lt;pending&gt;}Promise {&lt;resolved&gt;: "parameters..."}parameters...then....</code></pre><p>Combining the above code and results, we can see that by passing the asynchronous result to the resolve method, after calling the then method, it can receive a parameter, which will point to the asynchronous result. This makes it possible to use asynchronous results.</p><p>If you want to use the result of “reject” in the “then” function, it is also very simple. Pass a second callback function as a parameter, such as:</p><pre><code>p.then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }, (rej) =&gt; {        console.log(rej); });</code></pre><p>At a glance, I won’t go into details here.</p><p>However, if we should call the “then” function for multiple times, two functions are passed in each function to handle the success and failure results, which is sometimes cumbersome. Therefore, if all steps are processed with errors or failures, but only one kind of information need to be given to the user (such as network request error), you can use the following methods:</p><pre><code>p.then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).catch((rej) =&gt; {     console.log("fail..."); })</code></pre><p>If you want to implement the previous scenario that requires multiple callbacks, the code is as follows:</p><pre><code>let po = new Promise((resolve, reject) =&gt; {    resolve(1);});po.then((res) =&gt; {   console.log(res);   return 2;}).then((res) =&gt; {   console.log(res);   return 3;}).then((res) =&gt; {   console.log(res);   return 4;}).then((res) =&gt; {   console.log(res);})</code></pre><p>Result is：</p><pre><code>1234</code></pre><p>Obviously, the result returned by the “then” method can be obtained by the “then” method behind. But why is it available? We can assign a value to the result of the “then” method and print it. The code is:</p><pre><code>let po = new Promise((resolve, reject) =&gt; {     resolve(1); }); let pt = po.then((res) =&gt; {     console.log(res);     return "pt"; }) console.log(pt);</code></pre><p> Result is：</p><pre><code>Promise {&lt;pending&gt;}__proto__: Promise[[PromiseStatus]]: "resolved"[[PromiseValue]]: "pt"1</code></pre><p>After the above code is run, the last line of “pt” is printed. Because of the asynchronous reason, then the number “1” of the resolve passed into the “then” function is printed. The expansion result of “pt” can be seen that the “then” method will return a Promise object to us, and from the above results, it is seen that a Promise object with “resolved” state is returned.</p><p>Now that we all understand the use of promises, the example of moving blocks above can be rewritten as:</p><pre><code>function move(ele, dir, dist) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    return new Promise((resolve, reject) =&gt; {        clearInterval(ele.timer);        ele.timer = setInterval(() =&gt; {        if (Math.abs(curPos - dist) &lt;= 0) {                clearInterval(ele.timer);                 resolve();        } else {                curPos += speed;                ele.style[dir] = curPos + "px";        }        }, 20);    })}let box = document.querySelector("#box");move(box, "left", 100).then(() =&gt; {    return move(box, "top", 100);}).then(() =&gt; {    return move(box, "left", 0);}).then(() =&gt; {    return move(box, "top", 0);})</code></pre><p>The result is the same as the above result. But readability and code scalability have been significantly improved.</p><h4 id="Promise-“all”-function"><a href="#Promise-“all”-function" class="headerlink" title="Promise “all” function"></a>Promise “all” function</h4><p>After talking about the use of Promise and the use of “catch” and “then”, later, we will talk about another common method, Promise “all” function.</p><p>MDN’s description of the “all” method is:</p><pre><code>The Promise.all() method returns a single Promise that fulfills when all of the promises passed as an iterable have been fulfilled or when the iterable contains no promises. It rejects with the reason of the first promise that rejects.[3] </code></pre><p>For example, three different Promise objects are created, and the “all” method is called to execute the three Promise objects. If all three Promise objects are in the “resolved” state, then, can be executed downwards.</p><p>For example:</p><pre><code> let p1 = new Promise((resolve, reject) =&gt; {     console.log(1);     resolve(); });let p2 = new Promise((resolve, reject) =&gt; {     console.log(2);     resolve(); }); let p3 = new Promise((resolve, reject) =&gt; {     console.log(3);     resolve(); }); Promise.all([p1, p2, p3]).then(() =&gt;{     console.log(4); })</code></pre><p>Result:</p><pre><code>1234</code></pre><p>If the execution status of any Promise object is rejected. You need to use catch method to catch errors in “then” or at the end of the code, otherwise an error will be reported.</p><h3 id="Promise-“race”-function"><a href="#Promise-“race”-function" class="headerlink" title="Promise “race” function"></a>Promise “race” function</h3><p>This method is exactly the opposite of the all method. The all method is executed. And after all execution is complete, the following content is executed. As the name of the race method implies, when one of the executions of Promise objects ends, the following method starts to execute. code show as below:</p><pre><code> let p1 = new Promise((resolve, reject) =&gt; {     setTimeout(() =&gt; {        console.log(1);        resolve();     }, 2000); });let p2 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        console.log(2);        resolve();     }, 1000); }); let p3 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        console.log(3);        resolve();     }, 5000); }); Promise.race([p1, p2, p3]).then(() =&gt;{     console.log(4); }).catch(() =&gt; {     console.log("err"); });</code></pre><p>结果是：</p><pre><code>2413</code></pre><p>In the above code, we set the execution time of “p1” to 2s, “p2” to 1s, and “p3” to 5s. As can be seen from the results, after the execution of “p1”, the following “then” method is directly executed, so the printing order is 2, 4 and the last two will finish later.</p><h3 id="Async-and-Await"><a href="#Async-and-Await" class="headerlink" title="Async and Await"></a>Async and Await</h3><p>Sometimes when using the series of Promise methods, I still feel that the readability is general and the code scalability is limited. At this time, you can use Async and Await in combination with Promise. The sample code is as follows:</p><pre><code>async function fn () {    let p1 = await new Promise((resolve) =&gt; {        console.log(1);        resolve(2);    });    let p2 = await new Promise((resolve) =&gt; {        console.log(p1);        resolve(3);    });    let p3 = await new Promise((resolve) =&gt; {        console.log(p2);        resolve(4);    });    console.log(p3);}fn();Result is：1234</code></pre><p>Async and Await further simplify the amount of code, optimize the writing, and are by far it is the most commonly used asynchronous writing.</p><p>Note:</p><ol><li>“Await” is followed by a method that returns a Promise object or creates a new Promise object.</li><li>“Await” must be placed in the function marked by “Async”.</li><li>If you need to catch an exception, you can use “try {} catch (exception) {}” to write “await” into the code block after “try”.</li><li>The “Async” function returns a Promise, and the status is “resolved”.</li><li>“Await” can accept non-Promise object as the result of an await expression. But no matter what is behind await, it will block the execution of the internal code of the “async” function. If there is an external code at this time, the external code is executed first, and then it returns to the internal execution.</li><li>If the code in async is synchronous, then it executes synchronously.</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Promise is almost finished, and also briefly talked about Async and Await. It feels that the most important part is to know how to use them. As for Generator, I have never heard of it before, and I feel that it is less used, so I’ll look for a chance to talk about it later.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p><p>[2] <a href="https://www.jianshu.com/p/1ab01ee4102a" target="_blank" rel="noopener">https://www.jianshu.com/p/1ab01ee4102a</a></p><p>[3] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> Front End Development </tag>
            
            <tag> Web Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6_summary_1</title>
      <link href="/en/2020/01/28/es6_summary_1/"/>
      <url>/en/2020/01/28/es6_summary_1/</url>
      
        <content type="html"><![CDATA[<center> <h1>ES6 Summary #1</h1> </center><center> <h2> <font color="lightgray">Let, Const and Var</font> </h2> </center><font size="3"><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>I have learned and got in touch with Front End Development for several years. Most experiences from university and internship. But I don’t have too many industrial level experiences. Speaking of Front End Development, I should talk about the history of Front End. From the simplest UI-like work, till now, various Front End Frameworks have emerged in endlessly, and Front End Development has also changed from insignificant to become as important as back-end now in web development. Also due to the development of Web Front End technology in recent years, IOS and Android technologies have been squeezed and gradually been merged into the Front End Development in some company. This makes the importance of Front End of Web development faintly surpasses the importance of Back End Development.</p><p>The above is my personal understanding of the changes in the Front End. Excluding Android and IOS, Front End technology, no matter what framework or library you use, JavaScript is always the foundation and the most important part. JavaScript is mainly composed of ECMAScript (core), DOM (Document Object Model) and BOM (Browser Object Model).</p><p>ES6 (ECMAScript 6) was launched in 2015, and it has been launched for a few years. With the development in recent years, many new features have been added. Although there are a few versions later than ES6, like ES2017 and ES2019, it seems that the penetration rate is not as high as ES6, and the compatibility is even less. Having said that, ES6 guarantees a certain degree of backward compatibility. I will summarize some new basic knowledge points of ES6 later, including new keywords, new concepts, etc.</p><h2 id="Compatibility-of-ES6"><a href="#Compatibility-of-ES6" class="headerlink" title="Compatibility of ES6"></a>Compatibility of ES6</h2><p>First let’s talk about the compatibility of ES6. ES6 supports most of the latest versions of browsers, including Edge, Firefox 68+, Chrome 78+, Opera65 +, Safari 12.1+ and other desktop browsers. The support rate is almost 100%. Mobile browsers, including IOS12 +, Samsung 9+, OperaMobile 54+ are also close to 100% compatible. As for IE, it is basically not supported, but you can convert ES6 code to ES5 code.</p><h3 id="Compatibility-of-ES6-with-IE-and-other-browsers"><a href="#Compatibility-of-ES6-with-IE-and-other-browsers" class="headerlink" title="Compatibility of ES6 with IE (and other browsers)"></a>Compatibility of ES6 with IE (and other browsers)</h3><ol><li>Compatible with basic syntax (excluding promises and some classes)</li></ol><p>Before importing other scripts, import browser.min.js and set the type of the script tag to text / babel</p><ol start="2"><li>If using new features like Promise</li></ol><p>Babel compiles and converts JavaScript statements by default, and cannot convert new APIs. But Polyfill technology can be used. Import browser-polyfill to the development page:</p><pre><code>&lt;script type="text/javascript" src="你的browser-polyfill路径"&gt;&lt;/script&gt;</code></pre><h2 id="The-use-of-“let”-“const”-and-the-difference-with-“var”"><a href="#The-use-of-“let”-“const”-and-the-difference-with-“var”" class="headerlink" title="The use of “let”, “const” and the difference with “var”"></a>The use of “let”, “const” and the difference with “var”</h2><p>Let and const are new keywords in ES6. They have the same effect as var and are used to declare variables. But there are also many differences between them. If you need to consider more compatibility, it is better to use var. Let’s talk about their uses and differences.</p><h3 id="let’s-talk-about-“var”-first"><a href="#let’s-talk-about-“var”-first" class="headerlink" title="let’s talk about “var” first:"></a>let’s talk about “var” first:</h3><ul><li><p>scope of “var” is global or entire function block</p></li><li><p>varibles defined by “var” can be pre-parsed, that is, variables can be used before definition, such as:</p><p>  <code>console.log(a); var a = 10;</code></p></li><li><p>varibles defined by “var” can be redefined:</p><p>  <code>var a = 10; console.log(a); var a = 20; console.log(20);</code> result is 10 20</p></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>Variables or statements and expressions declared by “let”, the scope of “let” is block-level scope (simple and rough can be understood as a block-level scope surrounded by two braces)</p></li><li><p>In the same scope, “let” cannot be repeatedly declared, for example:：</p><p>  <code>let a = 10; console.log(a); let a = 20;</code> </p><p>  The above code will report an error because the “a” variable is repeatedly declared in the same scope.</p></li><li><p>let cannot be pre-parsed, that is:</p><p>  <code>console.log(a); let a = 10;</code> <font color="red">will cause an error</font></p></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const is simple, it has all the features of let, and the variables defined are constants and cannot be repeatedly assigned.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>I have introduced the basics of “let”, “const”, and “var” above. It is very simple. The emergence of “let” and “const” has optimized the declaration of variables, expressions, and so on. If you don’t consider compatibility, let’s use “let” instead of “var”.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.jianshu.com/p/13444c467ce2" target="_blank" rel="noopener">https://www.jianshu.com/p/13444c467ce2</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla</a></li></ul></font><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> Front End Development </tag>
            
            <tag> Web Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My First Blog - New Beginning</title>
      <link href="/en/2019/11/23/my_first_blog_new_beginning/"/>
      <url>/en/2019/11/23/my_first_blog_new_beginning/</url>
      
        <content type="html"><![CDATA[<center> <h1> My First Blog</h1></center><center> <h2> <font color="lightgray">New Beginning</font></h2></center><font size="4">Hello I am Kuncheng Li. I graduated from USC (University of Southern California) at May 10th, 2019. My major is Computer Science. I am still seeking full time Software Engineer position in the US now. <p>I have learned Computer Science for more than five years during undergraduate study and master study. I took my undergraduate degree in the UK. My university is University of Essex. It located in the oldest town in UK - Colchester. </p><p>During these a few years. I learned a lot of different kinds of technical stacks. For example, Java, Spring, Python, Django, HTML, CSS, JavaScript, Vue.js, React.js, Angular, MySQL, Redis and other kind of technologies which are belong to other technical area. My knowledge is widely enough. But I need to find out my future career direction for those technologies. And I need to learn the relevant technologies deeply.</p><p>As a result, I built and deployed this personal blog. I hope to record that kownledge points I need to remember, mistakes I have met during developing projects and my personal understanding of the technologies I have learned. </p><p>My current plan is that to revise knowledge about Java, record the key points, errors occured during the learning period and so on. </p><p>In the future, I will revise more and more technologies which I was learned before. </p><p>Thank you.</p><p>Kuncheng Li<br></p></font><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Some Feelings </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trival Talks </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
