<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>es6的一些知识点整理2</title>
      <link href="/2020/01/17/es6_de_yi_xie_zhi_shi_dian_zheng_li_2/"/>
      <url>/2020/01/17/es6_de_yi_xie_zhi_shi_dian_zheng_li_2/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理 - 2</h1> </center><center> <h2> <font color="lightgray">异步与同步</font> </h2> </center><h3 id="异步和同步是一种消息通知机制。"><a href="#异步和同步是一种消息通知机制。" class="headerlink" title="*异步和同步是一种消息通知机制。*"></a><strong>*<u>异步和同步是一种消息通知机制。</u>*</strong></h3><h2 id="什么是异步？"><a href="#什么是异步？" class="headerlink" title="什么是异步？"></a>什么是异步？</h2><h3 id="异步非阻塞："><a href="#异步非阻塞：" class="headerlink" title="异步非阻塞："></a>异步非阻塞：</h3><pre><code>比如： A调用B，B处理同时，A继续执行。B处理结束，返回结果，A再用B的结果执行。A在此期间不用等B执行结束。</code></pre><h3 id="同步阻塞："><a href="#同步阻塞：" class="headerlink" title="同步阻塞："></a>同步阻塞：</h3><pre><code>比如： A调用B，B处理完后返回结果给A，A继续执行。A在此期间一直等B执行结束。正常代码的执行，是逐行执行的，就是同步机制。</code></pre><h3 id="实现异步的最基本方法：使用计时器"><a href="#实现异步的最基本方法：使用计时器" class="headerlink" title="实现异步的最基本方法：使用计时器"></a>实现异步的最基本方法：使用计时器</h3><pre><code>function move(ele, dir, dist) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    clearInterval(ele.timer);    console.log("start moving...");    ele.timer = setInterval(() =&gt; {       if (Math.abs(curPos - dist) &lt;= 0) {            clearInterval(ele.timer);            console.log("finish moving...");       } else {            curPos += speed;            ele.style[dir] = curPos + "px";       }    }, 20);    console.log("printing....");}let box = document.querySelector("#box");move(box, "left", 100);</code></pre><p>上述代码会产生下图效果：</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/code-result1.gif" alt="代码运行结果"></p><p>打印结果如下：</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/code-result2.png" alt="代码运行打印结果"></p><p>从运行结果可以看出，printing在方块移动结束前打印了，并没有像常规的程序那样顺序执行。这就是最基本的异步的实现。</p><h3 id="异步结束完需要操作怎么办？"><a href="#异步结束完需要操作怎么办？" class="headerlink" title="异步结束完需要操作怎么办？"></a>异步结束完需要操作怎么办？</h3><p>肯定有很多解决方法，但是我认为比较好的方法是回调函数的方法，修改上述代码：</p><pre><code>function move(ele, dir, dist, callback) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    clearInterval(ele.timer);    console.log("start moving...");    ele.timer = setInterval(() =&gt; {       if (Math.abs(curPos - dist) &lt;= 0) {            clearInterval(ele.timer);            console.log("finish moving...");            callback &amp;&amp; callback(); // ===&gt;此处先判断是否存在callback，如果存在就执行       } else {            curPos += speed;            ele.style[dir] = curPos + "px";       }    }, 20);    console.log("printing....");}let box = document.querySelector("#box");move(box, "left", 100, () =&gt; {    console.log("执行回调函数");});</code></pre><p> 上述代码执行结果是：</p><pre><code>start moving...printing....finish moving...执行回调函数</code></pre><p>这样就能很好的解决异步执行之后需要用到异步的结果或者需要执行某些代码的问题。</p><h3 id="这种实现异步和回调的问题：回调地狱"><a href="#这种实现异步和回调的问题：回调地狱" class="headerlink" title="这种实现异步和回调的问题：回调地狱"></a>这种实现异步和回调的问题：回调地狱</h3><p>所谓回调地狱，就是多次回调，致使层数过深，如下：</p><pre><code>move(box, "left", 100,() =&gt; {    move(box, "top", 100,() =&gt; {        move(box, "left", -100,() =&gt; {            move(box, "top", -100,() =&gt; {                console.log("finish...");            });        });    });});</code></pre><p>上述代码层数过深，不利于代码的复用性和阅读性。</p><h2 id="回调地狱解决办法"><a href="#回调地狱解决办法" class="headerlink" title="回调地狱解决办法"></a>回调地狱解决办法</h2><p>解决办法有三种，分别是使用<strong>Promise</strong> ，使用<strong>Async和Await</strong>以及使用<strong>Generator</strong>函数。这一篇文章先讲一下Promise的使用。</p><h3 id="Promise的概念以及使用"><a href="#Promise的概念以及使用" class="headerlink" title="Promise的概念以及使用"></a>Promise的概念以及使用</h3><p><strong><em>Promise不是解决异步问题本身，而是解决异步的写法问题，使异步写法更清晰。</em></strong></p><p>先说下Promise，在MDN，Promise被如下定义：</p><pre><code>Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.[1]</code></pre><p>Promise有三个状态：<b>Pending（在等待异步流程执行完毕）；Fulfilled或者Resolved（成功）；Rejected（失败）</b>。<br>异步操作的结果决定了当前状态，其它内容无法干扰Promise状态。且，Promise如果状态改变，则不会再变，比如从pending改变到rejected，就不会再回到pending，或者再变为fulfilled。[2]</p><p>接下来展示一段Promise的简单使用：</p><pre><code>let p = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            console.log(p);            resolve();        }, 2000);     });    p.then(() =&gt; {        console.log(p);        console.log("then....");    }); </code></pre><p>then方法就相当于之前实现多次异步时候的回调函数，根据上述代码，可以发现Promise创建后传入一个函数，函数的参数是两个函数resolve和reject，分别对应着rejected和resolved（fulfilled）两个状态。现在就一目了然了，如果异步执行成功，则调用运行resolve()，反之运行reject()。上述运行结果为：</p><p>程序运行两秒后，打印如下内容：</p><pre><code>Promise {&lt;pending&gt;}Promise {&lt;resolved&gt;: undefined}then....</code></pre><p>由此可见，如果异步执行成功，调用resolve函数，则程序会向下执行到then，而且从打印的两个p我们能看出，Promise的状态从pending向resolved改变。</p><h4 id="那如何使用异步结果呢？"><a href="#那如何使用异步结果呢？" class="headerlink" title="那如何使用异步结果呢？"></a>那如何使用异步结果呢？</h4><p>很多时候，异步产生的结果，是我们后面要使用的，那么如果像上述一样用Promise来优化异步的写法，我们如何使用异步结果呢？</p><p>其实答案已经在上述代码出现了。上述代码的打印结果的第二行，Promise状态resolved后面有一个undefined。这个地方，就是用来存异步结果的。代码可以改动如下：</p><pre><code>let p = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            console.log(p);            resolve("parameters..."); // =======》这里执行resolve时候可以传入参数。        }, 2000);  }); p.then((res) =&gt; { // ======》这里能传入一个参数，比如res        console.log(p);        console.log(res);                 console.log("then...."); });</code></pre><p>运行结果如下：</p><pre><code>Promise {&lt;pending&gt;}Promise {&lt;resolved&gt;: "parameters..."}parameters...then....</code></pre><p>结合上述代码和结果，我们能看出来，通过向resolve方法传入异步结果，在调用then方法后，可以接收一个参数，这个参数就指向异步的结果。从而就能使用异步结果了。</p><p>如果想在then函数中处理reject的结果，那么也很简单，传入第二个回调函数作为参数，比如：</p><pre><code>p.then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }, (rej) =&gt; {        console.log(rej); });</code></pre><p>一目了然，在此就不做赘述了。</p><p>但是如果存在需要链式调用then函数，每个函数中都传入两个函数来处理成功和失败的结果，有时候会比较繁琐，因此，如果所有步骤处理出现错误或者失败，都只需要返回一种信息给用户（比如网络请求错误），可以用以下办法：</p><pre><code>p.then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).catch((rej) =&gt; {     console.log("fail..."); })</code></pre><p>如果想实现之前那种需要多次回调的场景也很简单，代码如下：</p><pre><code>let po = new Promise((resolve, reject) =&gt; {    resolve(1);});po.then((res) =&gt; {   console.log(res);   return 2;}).then((res) =&gt; {   console.log(res);   return 3;}).then((res) =&gt; {   console.log(res);   return 4;}).then((res) =&gt; {   console.log(res);})</code></pre><p> 运行结果是：</p><pre><code>1234</code></pre><p>很显然，then方法最后return的结果是可以被后面的then方法获取到的。但是为什么能获取呢？我们可以给调用then方法的结果赋值，打印看下。代码为：</p><pre><code>let po = new Promise((resolve, reject) =&gt; {     resolve(1); }); let pt = po.then((res) =&gt; {     console.log(res);     return "pt"; }) console.log(pt);</code></pre><p> 结果为：</p><pre><code>Promise {&lt;pending&gt;}__proto__: Promise[[PromiseStatus]]: "resolved"[[PromiseValue]]: "pt"1</code></pre><p>上述代码运行后先打印了最后一行的pt。因为异步的原因，然后打印了resolve传入then函数的数字1。pt的展开结果我们可以看出，then方法会给我们返回一个Promise对象，而且从上述结果看出，返回的是一个resolved状态的Promise对象。</p><p>现在我们都了解到Promise的用法了，上文中的移动方块的例子能改写为：</p><pre><code>function move(ele, dir, dist) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    return new Promise((resolve, reject) =&gt; {        clearInterval(ele.timer);        ele.timer = setInterval(() =&gt; {        if (Math.abs(curPos - dist) &lt;= 0) {                clearInterval(ele.timer);                 resolve();        } else {                curPos += speed;                ele.style[dir] = curPos + "px";        }        }, 20);    })}let box = document.querySelector("#box");move(box, "left", 100).then(() =&gt; {    return move(box, "top", 100);}).then(() =&gt; {    return move(box, "left", 0);}).then(() =&gt; {    return move(box, "top", 0);})</code></pre><p>运行结果和上述结果一样。但是可读性和代码可扩展性得到了显著的提高。</p><h4 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise all方法"></a>Promise all方法</h4><p>说完Promise的使用和then还有catch常用方法，接着说下Promise的另一个常用方法 - all方法。</p><p>MDN对于all方法的说明是：</p><pre><code>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数    中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失    败原因的是第一个失败 promise 的结果。[3] </code></pre><p>简单说就是比如创建了三个不同的Promise对象，调用all方法执行三个Promise对象，如果三个都是resolved状态，则可以向下执行。</p><p>例子：</p><pre><code> let p1 = new Promise((resolve, reject) =&gt; {     console.log(1);     resolve(); });let p2 = new Promise((resolve, reject) =&gt; {     console.log(2);     resolve(); }); let p3 = new Promise((resolve, reject) =&gt; {     console.log(3);     resolve(); }); Promise.all([p1, p2, p3]).then(() =&gt;{     console.log(4); })</code></pre><p>结果：</p><pre><code>1234</code></pre><p>如果任意一个Promise对象的执行状态是rejected。则需要在then中或者或者代码最后使用catch方法捕获错误，不然会报错。</p><h3 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise race方法"></a>Promise race方法</h3><p>这个方法和all方法正好相反，all方法是全部执行结束，才执行下面的内容。race方法顾名思义，有其中一项执行结束，则开始执行下面的方法。代码如下：</p><pre><code> let p1 = new Promise((resolve, reject) =&gt; {     setTimeout(() =&gt; {        console.log(1);        resolve();     }, 2000); });let p2 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        console.log(2);        resolve();     }, 1000); }); let p3 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        console.log(3);        resolve();     }, 5000); }); Promise.race([p1, p2, p3]).then(() =&gt;{     console.log(4); }).catch(() =&gt; {     console.log("err"); });</code></pre><p>结果是：</p><pre><code>2413</code></pre><p>上面代码我们把p1的执行时间设置为2s，p2是1s，p3是5s，从结果就能看出，p1执行结束后，直接执行下面的then方法，因此打印顺序是2，4接着两个分别按照设定时间执行完毕。</p><h3 id="Async和Await写法"><a href="#Async和Await写法" class="headerlink" title="Async和Await写法"></a>Async和Await写法</h3><p>有时候用Promise的一系列方法，仍然感觉可读性一般，代码扩展性也有局限，那么这时候，可以用Async和Await结合Promise使用。示例代码如下：</p><pre><code>async function fn () {    let p1 = await new Promise((resolve) =&gt; {        console.log(1);        resolve(2);    });    let p2 = await new Promise((resolve) =&gt; {        console.log(p1);        resolve(3);    });    let p3 = await new Promise((resolve) =&gt; {        console.log(p2);        resolve(4);    });    console.log(p3);}fn();打印结果：1234</code></pre><p>Async和Await进一步简化了代码量，优化了写法，也是现今为止最常用的异步写法。<br>注意：</p><ol><li>Await 后面接一个能返回Promise对象的方法或者创建一个新Promise对象。</li><li>Await必须放在Async标示的函数当中。</li><li>如果需要捕获异常，可以用try{} catch (exception) {}，把await写入try后面的代码块中。</li><li>Async函数返回一个Promise，状态是resolved。</li><li>Await可接受非Promise作为await表达式的结果。但是不管await后面是什么，都会阻塞async函数内部代码执行，如果这时有外部代码，则先执行外部代码，之后再回到内部执行。</li><li>如果async中代码是同步代码，那就同步执行。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Promise差不多就说完了，也简单说了下Async和Await。感觉会用是最关键的。至于Generator，听说过没用过，感觉用的比较少，以后找机会再说吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p><p>[2] <a href="https://www.jianshu.com/p/1ab01ee4102a" target="_blank" rel="noopener">https://www.jianshu.com/p/1ab01ee4102a</a></p><p>[3] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6的一些知识点整理</title>
      <link href="/2020/01/02/es6_de_yi_xie_zhi_shi_dian_zheng_li/"/>
      <url>/2020/01/02/es6_de_yi_xie_zhi_shi_dian_zheng_li/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理</h1> </center><center> <h2> <font color="lightgray">基础部分</font> </h2> </center><font size="3"><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>接触前端也很久了，当然主要都是在学校，工业级的不太多，仅仅是实习中的有限的时间接触了一些。说到前端，不得不说前端的发展历程，从最简单的类似UI的工作，到现在，各种前端框架层出不穷，前端开发也从Web开发的无足轻重，变成现在和后端一样的重要。同样由于近几年Web前端技术的发展，IOS和Android技术被挤压的很厉害，也渐渐并入前端当中。使得现在前端在Web开发中占有的比重隐隐超过后端。</p><p>以上是我个人对前端变化的理解。排除Android和IOS，Web前端技术，不论你是用什么框架，什么库，JavaScript永远是基础，也是最重要的一部分。JavaScript主要由ECMAScript（核心），DOM（文档对象模型）和BOM（浏览器对象模型）。</p><p>ES6（ECMAScript 6）是2015年推出的，也推出一段时间了，随着这几年发展，添加了很多新特性，虽然后面还有ES2017，ES2019，但是貌似普及率没有ES6高，兼容性更不要说了，ES6保证了一定的向下兼容性，后面我会总结下ES6的一些新出的基础知识点，包括新增关键词，新增概念等。</p><h2 id="ES6的兼容性"><a href="#ES6的兼容性" class="headerlink" title="ES6的兼容性"></a>ES6的兼容性</h2><p>首先先说ES6的兼容性，ES6支持绝大多数最新版本浏览器，包括Edge，Firefox 68+， Chrome 78+，Opera65+，Safari 12.1+等桌面版浏览器支持率几乎达到100%。移动版浏览器，包括IOS12+，Samsung 9+， OperaMobile 54+兼容程度也接近100%。至于IE，就基本不支持了，但是可以用代码转换。</p><h3 id="ES6兼容IE（和其它浏览器）的方法"><a href="#ES6兼容IE（和其它浏览器）的方法" class="headerlink" title="ES6兼容IE（和其它浏览器）的方法"></a>ES6兼容IE（和其它浏览器）的方法</h3><ol><li>兼容基本语法（不包括Promise之类的）</li></ol><p>在引入其它脚本前，引入browser.min.js， script标签的type设为text/babel</p><ol start="2"><li>如果使用Promise等新特性</li></ol><p>Babel默认编译转换JavaScript语句，不能转换新的API。但是可以使用Polyfill（代码填充）技术。在开发页面中引入browser-polyfill即可：</p><pre><code>&lt;script type="text/javascript" src="你的browser-polyfill路径"&gt;&lt;/script&gt;</code></pre><h2 id="let，const的使用以及它们和var的区别"><a href="#let，const的使用以及它们和var的区别" class="headerlink" title="let，const的使用以及它们和var的区别"></a>let，const的使用以及它们和var的区别</h2><p>let和const是ES6新出来的关键字，和var作用相同，用来声明变量。但是也有很多不同。如果需要考虑兼容性更多，还是推荐用var比较好。接下来说下它们的使用和区别。</p><h3 id="说let和const之前，先说说var的一些特性"><a href="#说let和const之前，先说说var的一些特性" class="headerlink" title="说let和const之前，先说说var的一些特性"></a>说let和const之前，先说说var的一些特性</h3><ul><li><p>var的作用域是全局或者整个函数块</p></li><li><p>var可以被预解析，也就是说，可以在定义前使用变量，比如：</p><p>  <code>console.log(a); var a = 10;</code>这个是不会报错的，因为var定义的a被预解析。</p></li><li><p>var定义的变量在同一作用域下能重复定义</p><p>  <code>var a = 10; console.log(a); var a = 20; console.log(20);</code> 结果是10 20</p></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>let声明的变量或者语句以及表达式，作用域为块级作用域（简单粗略可以理解成是两个大括号包裹着是一个块级作用域）</p></li><li><p>同一作用域下，let不能重复声明，比如：</p><p>  <code>let a = 10; console.log(a); let a = 20;</code> 上述代码会报错，因为在同一个作用域中重复声明了a变量。</p></li><li><p>let不能被预解析，也就是：</p><p>  <code>console.log(a); let a = 10;</code>是会报错的。</p></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 就没什么可说的了，它拥有let的所有特性，并且定义的变量为常量，不可重复赋值。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>let，const和var基本介绍完了，很简单，let和const的出现，优化了声明变量，表达式等。如果不考虑兼容性，推荐使用let代替var。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.jianshu.com/p/13444c467ce2" target="_blank" rel="noopener">https://www.jianshu.com/p/13444c467ce2</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla</a></li></ul></font><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一个博客 - 新起点</title>
      <link href="/2019/11/23/wo_de_di_yi_ge_bo_ke_xin_de_kai_shi/"/>
      <url>/2019/11/23/wo_de_di_yi_ge_bo_ke_xin_de_kai_shi/</url>
      
        <content type="html"><![CDATA[<center> <h1>我的第一个博客</h1> </center><center> <h2> <font color="lightgray">新起点</font> </h2> </center><font size="4">您好，我是Kingsley。我于2019年5月10日毕业于南加州大学（USC）。我的专业是计算机科学。我现在仍在找美国的全职软件工程师职位。<p>在本科学习和硕士学习期间，我已经学习计算机科学超过五年了。我在英国获得了本科学位。我的大学是埃塞克斯大学。它位于英国最古老的城镇-科尔切斯特。</p><p>在这几年中。我学到了很多不同类型的技术栈。例如，Java，Spring，Python，Django，HTML，CSS，JavaScript，Vue.js，React.js，Angular，MySQL，Redis和属于其他技术领域的技术。我的知识足够广泛。但是我需要找出这些技术的未来职业方向。而且我需要深入学习相关技术。</p><p>因此，我建立并部署了此个人博客。我希望记录下我需要记住的知识点，在开发项目期间遇到的错误以及对所学技术的个人理解。</p><p>我目前的计划是修正和复习有关Java的知识，记录要点，学习期间发生的错误等。</p><p>将来，我将复习和修正越来越多我以前学过的的技术的要点。</p><p>谢谢。</p></font><p><font size="4">K.L<br></font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 一些感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 琐碎杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
