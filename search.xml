<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>es6的一些知识点整理4</title>
      <link href="/2020/02/02/es6_de_yi_xie_zhi_shi_dian_zheng_li_4/"/>
      <url>/2020/02/02/es6_de_yi_xie_zhi_shi_dian_zheng_li_4/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理 - 4</h1> </center><center> <h2> <font color="lightgray">基础部分</font> </h2> </center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介绍了很多关于ES6的新增功能，比如let和const，块状作用域，解构赋值，展开运算符，异步同步等。今天想说一下set和map这两个数据结构。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>先说一下set，Javascript的set类似于其它语言的set，其最大作用就是可以去重，MDN对set的描述是：</p><pre><code>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。[1]</code></pre><p>下面是一个set的例子：</p><pre><code>    let arr = [1,2,3,3,1,2,4];    let set = new Set(arr);    console.log(set);</code></pre><p>运行结果是：</p><pre><code>Set(4) {1, 2, 3, 4}</code></pre><p>通过上述代码，我们能很快很方便的把数组转换成set，数组中的重复的值都被去除掉了。</p><h3 id="Set的常用方法-add-delete-has-clear，forEach"><a href="#Set的常用方法-add-delete-has-clear，forEach" class="headerlink" title="Set的常用方法 - add, delete, has, clear，forEach"></a><strong>Set的常用方法 - add, delete, has, clear，forEach</strong></h3><h3 id="1-add方法"><a href="#1-add方法" class="headerlink" title="1. add方法"></a>1. add方法</h3><p>顾名思义，add方法是向set中添加值的方法。如下方的代码：</p><pre><code>    let arr = [1,2,3,3,1,2,4];    let set = new Set(arr);    console.log(set);    set.add('a');    set.add(1);    set.add(1.1);    console.log(...set);</code></pre><p>结果是：</p><pre><code>    1 2 3 4 "a" 1.1</code></pre><p>通过上方代码，我们分别添加了字符串a，数字1和数字1.1，从结果能看出，添加的值是逐个加入到set后面的，并且由于数字1存在，因此不会被重复添加进去。而且很容易看出，set不是一个固定数据类型的数据结构。至于返回值，add方法的返回值是set本身。</p><h3 id="2-delete方法"><a href="#2-delete方法" class="headerlink" title="2. delete方法"></a>2. delete方法</h3><p>接下来看一下delete方法，这个方法可以帮助我们删除掉set内的指定值。如果要删除的值存在，则删除，如果不存在，则不操作，比如如下代码：</p><pre><code>    let arr = [1,2,3,3,1,2,4, "a", 2.2];    let set = new Set(arr);    console.log(...set);    let res1 = set.delete(1);    console.log(...set);    let res2 =  set.delete(1.1);    console.log(...set);    set.delete("a");    console.log(...set);    console.log(res1, res2);</code></pre><p>结果是：</p><pre><code>1 2 3 4 "a" 2.22 3 4 "a" 2.22 3 4 "a" 2.22 3 4 2.2true false</code></pre><p>从结果的打印，能很容易的看出，当删除1时候，删除成功，之后删除1.1，由于1.1不存在，因此没有操作，最后删除字符串a，删除成功。而且从打印的返回值res1和res2我们能看出，如果删除成功，返回值是true，否则是false。这个返回值，有时候会帮助我们用于判断，决定接下来的操作。</p><h3 id="3-has方法"><a href="#3-has方法" class="headerlink" title="3. has方法"></a>3. has方法</h3><p>has方法很明显，用来判断set中是否存在某个值，MDN对其的描述是：</p><pre><code>has() 方法返回一个布尔值来指示对应的值value是否存在Set对象中。[2]</code></pre><p>接下来一个例子：</p><pre><code>    let arr = [1,2,3,3,1,2,4, "a", 2.2];    let set = new Set(arr);    console.log(...set);    console.log(set.has(1));    console.log(set.has("a"));    console.log(set.has(999));</code></pre><p>结果是：</p><pre><code>1 2 3 4 "a" 2.2truetruefalse</code></pre><p>通过结果，我们能看出，set中包含数字1，2，3，4，字符串a以及浮点数2.2，当我们判断是否存在1和”a”时，由于存在，返回true，当判断999时，因为不存在，则返回false。</p><h3 id="4-clear方法"><a href="#4-clear方法" class="headerlink" title="4. clear方法"></a>4. clear方法</h3><p>接着看下clear方法，这个方法就没什么可说了，就是很简单的清空set。这个方法返回值是undefined。而且不管set是不是空的，都不报错。一个例子如下：</p><pre><code>    let arr = [1,2,3,3,1,2,4, "a", 2.2];    let set = new Set(arr);    console.log(...set);    set.clear();    console.log(set);    set.clear();    console.log(set);</code></pre><p>结果是：</p><pre><code>1 2 3 4 "a" 2.2Set(0) {}Set(0) {}</code></pre><p>显而易见，set被清空，而且重复调用也不会出错。</p><h3 id="5-forEach方法"><a href="#5-forEach方法" class="headerlink" title="5. forEach方法"></a>5. forEach方法</h3><p>forEach方法是很多数据结构都有的方法，用来迭代数据结构中的所有项。MDN描述如下：</p><pre><code>forEach 方法会根据集合中元素的插入顺序，依次执行提供的回调函数。[3]</code></pre><p>从描述中能看出，forEach方法迭代的值和索引，是通过回调函数来使用的，代码如下：</p><pre><code>    let arr = [1,2,3,3,1,2,4, "a", 2.2];    let set = new Set(arr);    set.forEach((val, key, set) =&gt; {        console.log(val,":",key, ":", set);    })</code></pre><p>结果如下：</p><pre><code>1 ":" 1 ":" Set(6) {1, 2, 3, 4, "a", …}2 ":" 2 ":" Set(6) {1, 2, 3, 4, "a", …}3 ":" 3 ":" Set(6) {1, 2, 3, 4, "a", …}4 ":" 4 ":" Set(6) {1, 2, 3, 4, "a", …}a : a : Set(6) {1, 2, 3, 4, "a", …}2.2 ":" 2.2 ":" Set(6) {1, 2, 3, 4, "a", …}</code></pre><p>set的forEach函数第一个参数也是一个回调函数，类似于其他数据结构，但是set的forEach和数组有些不同，由于set没有索引，因此，回调函数的第一个value值和第二个key值都是当前操作项的值。与此同时，他还能接收第三个参数，第三个参数是这个值来源于的哪个数组。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>说完了set，那就不能不说map了，本来想分两篇文章写，但是想了想，还是写了吧。先看下Map在MDN中的描述：</p><pre><code>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。[4]</code></pre><p>下面代码，是map的简单使用：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);    let map2 = new Map([1, 'one'], [2, 'two'], [3, 'three']);    console.log(map2);</code></pre><p>结果是：</p><pre><code>Map(3) {1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}Uncaught TypeError: Iterator value 1 is not an entry objectat new Map (&lt;anonymous&gt;)at demo2.html:110</code></pre><p>从结果我们能看出，创建map不能用下面创建map2的方式，会报错，通过错误提示，我们能看出，创建map时候，传入的必须是一个可迭代的数据结构， 比如数组。接下来看看map的几个常用方法。上述代码中，key是数字1，2，3 等，value是各个key对应的英文单词。</p><h3 id="Map的常用方法-set-get-keys-values-delete-has-clear，forEach"><a href="#Map的常用方法-set-get-keys-values-delete-has-clear，forEach" class="headerlink" title="Map的常用方法 - set, get, keys, values, delete, has, clear，forEach"></a><strong>Map的常用方法 - set, get, keys, values, delete, has, clear，forEach</strong></h3><h3 id="1-set和get方法"><a href="#1-set和get方法" class="headerlink" title="1. set和get方法"></a>1. set和get方法</h3><p>先说下set和get方法，这两个方法很好理解，就是插入新的key-value对，和通过相应的key得到相应的value。下面看一下相应代码：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);    let setAns = map.set(4, "four");    console.log("map: ", map);    console.log("setAns: ", setAns);    let val = map.get(2);    console.log("getVal: ", val);    map.set(1, "oneoneone");    console.log("map: ", map);    console.log(map.get(333));</code></pre><p>结果是：</p><pre><code>Map(3) {1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}map:  Map(4) {1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three", 4 =&gt; "four"}setAns:  Map(4) {1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three", 4 =&gt; "four"}getVal:  twomap:  Map(4) {1 =&gt; "oneoneone", 2 =&gt; "two", 3 =&gt; "three", 4 =&gt; "four"}undefined</code></pre><p>通过上面结果我们能看出，set方法的返回值是map本身，get方法的返回值是获取到的value值，如果没有对应的key，则返回undefined。同时我们能轻松的看出插入和获取的操作，如果插入时，key值不存在，则插入key-value对。如果存在，则更新key对应的value值为新插入的值。</p><h3 id="2-keys和values方法"><a href="#2-keys和values方法" class="headerlink" title="2. keys和values方法"></a>2. keys和values方法</h3><p>通过keys和values方法，我们分别能得到相应的可迭代对象作为返回值，对象中分别按插入顺序存入了所有key值和value值。下面是keys和values的简单用法：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);    let keys = map.keys();    console.log("keys: ", keys);    let values = map.values();    console.log("values: ", values);</code></pre><p>结果是：</p><pre><code>Map(3) {1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}keys:  MapIterator {1, 2, 3}values:  MapIterator {"one", "two", "three"}</code></pre><p>通过结果我们能看出，keys和values方法的返回值都是MapIterator对象，我们能使用Iterator对象的相应方法获取相应的值。</p><h3 id="3-delete方法"><a href="#3-delete方法" class="headerlink" title="3. delete方法"></a>3. delete方法</h3><p>map的delete方法类似set中的delete方法，删除对应key值的value，删除成功返回true，失败返回false。简单用法如下：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);    let ans1 = map.delete(1);    console.log("map: ", map);    console.log("return answer after delete: ", ans1);    let ans2 = map.delete(1);    console.log("map: ", map);    console.log("return answer after delete: ", ans2);</code></pre><p>打印结果是：</p><pre><code>Map(3) {1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}map:  Map(2) {2 =&gt; "two", 3 =&gt; "three"}return answer after delete:  truemap:  Map(2) {2 =&gt; "two", 3 =&gt; "three"}return answer after delete:  false</code></pre><p>从结果显而易见，第一次调用delete，传入参数1，则成功删除key值1对应的值“one”，并且我们能看出，由于删除成功，返回值是true。而第二次再次删除数字1对应的值时，由于之前删除过，map中已经不存在key为1的项，因此删除失败，map不变，返回值为false。</p><h3 id="4-has方法"><a href="#4-has方法" class="headerlink" title="4. has方法"></a>4. has方法</h3><p>has方法也很简单，通过传入的key值，判断是否存在相应的键值对，如果存在则返回true，否则返回false。下面是简单用法：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);    console.log(map.has(1));    console.log(map.has("one"));</code></pre><p>打印结果为：</p><pre><code>Map(3) {1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}truefalse</code></pre><p>从结果能很快看出，当我们传入数字1时，由于map中存在这个key值，因此返回true，相反的，map中不存在“one”，因此第二个has返回的结果时false。</p><h3 id="5-clear方法"><a href="#5-clear方法" class="headerlink" title="5. clear方法"></a>5. clear方法</h3><p>clear方法就更简单了，就是清空map用的。clear方法的返回值是undefined。代码如下：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);    map.clear();    console.log(map);</code></pre><p>结果如下：</p><pre><code>Map(3) {1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}Map(0) {}</code></pre><p>结果显而易见，就不赘述了。</p><h3 id="6-forEach方法"><a href="#6-forEach方法" class="headerlink" title="6. forEach方法"></a>6. forEach方法</h3><p>map的forEach方法和set的略有不同，同样是传入一个回调函数作为参数，不同的是，回调函数的第一个和第二个参数，set由于没有索引，因此两个参数都是相应的值，但是map不同，map的forEach方法中的回调函数的第一个参数是键值对的value值，第二个是key值，下面的例子很清楚：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);    map.forEach((val, key) =&gt; {        console.log(key,":",val);    });</code></pre><p>结果是：</p><pre><code>Map(3) {1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}1 ":" "one"2 ":" "two"3 ":" "three"</code></pre><p>从结果能很容易看出，map的回调函数也有第三个参数，和set类似，返回这个map，在此不再多说了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天说了两个数据解构，set和map，这两个数据结构并不罕见，很多编程语言中都有，而且在javaScript中的用法和在其它语言中的用法也很类似。可以简单便捷的完成很多其它数据解构不容易完成的任务。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set</a></p><p>[2] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/has" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/has</a></p><p>[3] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach</a></p><p>[4] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6的一些知识点整理3</title>
      <link href="/2020/02/02/es6_de_yi_xie_zhi_shi_dian_zheng_li_3/"/>
      <url>/2020/02/02/es6_de_yi_xie_zhi_shi_dian_zheng_li_3/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理 - 3</h1> </center><center> <h2> <font color="lightgray">基础部分</font> </h2> </center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来想写一系列的ES6基础的博文，之后再总结一些ES6的高级功能，比如异步同步之类的，但是写完第一个文章后，忘记总结其它基础部分，就直接写了异步和同步。因此这篇文章开始，会继续总结ES6的新增功能和基础知识。应该会写几篇，之前那篇异步同步的文章感觉太长了，以后尽量控制篇幅。</p><h2 id="ES6-块级作用域"><a href="#ES6-块级作用域" class="headerlink" title="ES6 - 块级作用域"></a>ES6 - 块级作用域</h2><p>正如之前说的，ES6中新增的关键字 - let和const的作用范围是块级作用域。下面有个简单的例子用来对比let和var来说明块级作用域：</p><pre><code>    let b;    if (true) {        let a = 1;        b = 2;        var c = 3;        console.log("inside a: " + a);        console.log("inside c: " + c);    }    console.log("outside c: " + c);    console.log("outside a: " + a);    console.log("b: " + b);</code></pre><p>结果是：</p><pre><code>inside a: 1inside c: 3outside c: 3Uncaught ReferenceError: a is not defined</code></pre><p>结合代码和结果，显而易见，var定义的变量c，虽然被定义在if这个块内，但是能被外面用到，而let定义的变量a则不能。接下来再看个复杂的例子：</p><pre><code>    for(let i = 0; i &lt; 5; i++) {        setTimeout(function() {            console.log("i: " + i);        }, 1000);    }    let j;    for(j = 0; j &lt; 5; j++) {        setTimeout(function() {            console.log("j: " + j);        }, 2000);    }</code></pre><p>结果是：</p><pre><code>demo2.html:26 i: 0demo2.html:26 i: 1demo2.html:26 i: 2demo2.html:26 i: 3demo2.html:26 i: 45 demo2.html:33 j: 5</code></pre><p>我们可以看到，第一个for循环，i这个变量是在for循环块内定义的，由于let是块状作用域关键字，因此在这个for块中，i就好像一个实体，每次 + 1，都会产生一个实体。</p><p>第二个for循环，j是在for块外定义的，传入for块内，就像是传入了一个参数，并不作为一个实体在for循环内，因此每次 j + 1，都是修改外面变量指向的内存，并不会创建新的变量。</p><p>同样的代码，改成var的话，比如下面的代码：</p><pre><code>    for(var i = 0; i &lt; 5; i++) {        setTimeout(function() {            console.log("i: " + i);        }, 1000);    }    var j;    for(j = 0; j &lt; 5; j++) {        setTimeout(function() {            console.log("j: " + j);        }, 2000);    }</code></pre><p>结果是：</p><pre><code>5 i: 55 j: 5</code></pre><p>显而易见，i和j均打印了五次，因为var是全局作用域，所以在不在for循环内创建，都会只创建一个，因为是异步操作（上面也是）因此最后传入相应变量的值都是最后一个值，因此都是5。</p><p>以上是对块级作用域的一些见解和使用。如果有不恰当的地方，希望能指正，谢谢了。</p><h2 id="ES6-解构赋值"><a href="#ES6-解构赋值" class="headerlink" title="ES6 - 解构赋值"></a>ES6 - 解构赋值</h2><h3 id="解构赋值-对象"><a href="#解构赋值-对象" class="headerlink" title="解构赋值 - 对象"></a><strong>解构赋值 - 对象</strong></h3><p>接下来说一下ES6的新功能，就是解构赋值，这种功能大大的简化了对象或者数组的取值操作。比如下面代码：</p><pre><code>    let person = {        name: "personName",        age: 12,        weight: 55.5    }    let {name,age} = person;    console.log(name, " : ", age);    let {height} = person;    console.log(height);</code></pre><p>结果是：</p><pre><code>personName  :  12undefined</code></pre><p>上面是解构赋值的最简单用法，很容易获得对象内的相应的参数的值。但是有一点需要注意的是，解构的变量名必须和对象内的参数key值对应。</p><h3 id="解构赋值-数组"><a href="#解构赋值-数组" class="headerlink" title="解构赋值 - 数组"></a><strong>解构赋值 - 数组</strong></h3><p>同样的，可以用类似的方法解构数组，比如：</p><pre><code>    let arr = [1,2,3];    let [a,b] = arr;    console.log("a:", a,"b:",b);    let [d,c] = arr;    console.log("c:", c,"d:",d);</code></pre><p>结果是：</p><pre><code>a: 1 b: 2c: 2 d: 1</code></pre><p>通过结果能看出，解构数组，是通过值索引对应的，也就是第一个变量就是获得索引为0的值，以此类推。</p><h3 id="解构赋值-字符串"><a href="#解构赋值-字符串" class="headerlink" title="解构赋值 - 字符串"></a><strong>解构赋值 - 字符串</strong></h3><p>除了对象和数组，字符串也能解构赋值。如下方代码：</p><pre><code>    let str = "ABCD";    let [a,b] = str;    console.log(a,b);</code></pre><p>结果是：</p><pre><code>A B</code></pre><p>与数组差不多，字符串在解构时，也是会类似数组那样，按照索引获得。同样的，按照索引获取（数组和字符串等），不能用大括号来解构，但是解构对象，是要用大括号解构的。</p><h2 id="ES6-展开运算符"><a href="#ES6-展开运算符" class="headerlink" title="ES6 - 展开运算符"></a>ES6 - 展开运算符</h2><h3 id="展开运算符-数组"><a href="#展开运算符-数组" class="headerlink" title="展开运算符 - 数组"></a><strong>展开运算符 - 数组</strong></h3><p>接下来打算说下展开运算符（…）展开运算符类似解构赋值，可以用于数组和对象等，简化了对数组或对象内的各项的获取步骤。下面是展开运算符的简单使用：</p><pre><code>    let arr = [1,2,3];    console.log(arr);    console.log(...arr);</code></pre><p>结果是：</p><pre><code>(3) [1, 2, 3]1 2 3</code></pre><p>很明显，直接打印arr，则打印的是数组，可以展开查看各项，而使用展开运算符（三个点）则能获取到每一项，而不用像以前一样，要用循环或者其它方法。可见展开运算符有多方便。下面是展开运算符在数组的一些用法：</p><pre><code>    let arr = [1,2,3,4];    let arr2 = ["a", ...arr,"b"];    console.log(arr2);</code></pre><p>结果是：</p><pre><code>(6) ["a", 1, 2, 3, 4, "b"]</code></pre><p>展开运算符可以轻松的将数组中的所有项放入到另一个数组中。这样简化了很多类似的操作。接下来是一个稍微复杂些的用法：</p><pre><code>    let arr = [1,2,3,4];    let [a,...b] = arr;    console.log("a:",a," b:",b);</code></pre><p>结果是：</p><pre><code>a: 1  b: (3) [2, 3, 4]</code></pre><p>从上述能看出，a被赋值了数字1，b被赋值了一个数组，内容是除了1之外的其他数字。展开运算符能分别赋值变量，怎么赋值随开发要求而定，这种赋值方式十分方便。</p><h3 id="展开运算符-对象"><a href="#展开运算符-对象" class="headerlink" title="展开运算符 - 对象"></a><strong>展开运算符 - 对象</strong></h3><p>类似解构赋值，展开运算符可以很方便的用于对象，可以简化对象的赋值或者获取值的操作，比如：</p><pre><code>    let obj = {        a:1,        b:2    };    let obj2 = {        ...obj,        c:3,        d:4    }    console.log(obj2);</code></pre><p>结果是：</p><pre><code>{a: 1, b: 2, c: 3, d: 4}</code></pre><p>通过上述代码，我们轻松的将obj的参数和值添加到了obj2中。但是比如下方代码：</p><pre><code>    let obj = {        a:1,        b:2    };    let obj2 = {        ...obj,        a:3,        d:4    }    console.log(obj2);</code></pre><p>结果是：</p><pre><code>{a: 3, b: 2, d: 4}</code></pre><p>可见，如果obj2中存在obj中的key-value时，则不复制进去。接下来看看另一个例子，和上述数组中类似的例子：</p><pre><code>    let obj = {        a:1,        b:2    };    let obj2 = {        ...obj,        c:3,        d:4    }    let {a,...b} = obj2;    console.log(a, b);</code></pre><p>结果是：</p><pre><code>1 {b: 2, c: 3, d: 4}</code></pre><p>结果显而易见，类似展开数组一样，a被赋值1，b被赋值成一个新对象，对象中的参数是原obj2中，除了a之外的其它的参数。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章说了下块状作用域和解构赋值。还是很好理解的，但是由于let和const是块状作用域，var则不同。所以万一需要异步操作，还是要小心赋值的问题。</p><p>至于解构赋值，对象是以变量名对应对象参数key值来解构的，变量名必须和key值相同。其它类似数组和字符串，解构时，按照索引解构，不需要特定变量名。</p><p>展开运算符的很多用法类似于解构赋值。不管是展开运算符还是解构赋值，都很大的程度上简化了一些对象，数组或类似数据结构的值的获取和赋值。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6的一些知识点整理2</title>
      <link href="/2020/01/17/es6_de_yi_xie_zhi_shi_dian_zheng_li_2/"/>
      <url>/2020/01/17/es6_de_yi_xie_zhi_shi_dian_zheng_li_2/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理 - 2</h1> </center><center> <h2> <font color="lightgray">异步与同步</font> </h2> </center><h3 id="异步和同步是一种消息通知机制。"><a href="#异步和同步是一种消息通知机制。" class="headerlink" title="*异步和同步是一种消息通知机制。*"></a><strong>*<u>异步和同步是一种消息通知机制。</u>*</strong></h3><h2 id="什么是异步？"><a href="#什么是异步？" class="headerlink" title="什么是异步？"></a>什么是异步？</h2><h3 id="异步非阻塞："><a href="#异步非阻塞：" class="headerlink" title="异步非阻塞："></a>异步非阻塞：</h3><pre><code>比如： A调用B，B处理同时，A继续执行。B处理结束，返回结果，A再用B的结果执行。A在此期间不用等B执行结束。</code></pre><h3 id="同步阻塞："><a href="#同步阻塞：" class="headerlink" title="同步阻塞："></a>同步阻塞：</h3><pre><code>比如： A调用B，B处理完后返回结果给A，A继续执行。A在此期间一直等B执行结束。正常代码的执行，是逐行执行的，就是同步机制。</code></pre><h3 id="实现异步的最基本方法：使用计时器"><a href="#实现异步的最基本方法：使用计时器" class="headerlink" title="实现异步的最基本方法：使用计时器"></a>实现异步的最基本方法：使用计时器</h3><pre><code>function move(ele, dir, dist) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    clearInterval(ele.timer);    console.log("start moving...");    ele.timer = setInterval(() =&gt; {       if (Math.abs(curPos - dist) &lt;= 0) {            clearInterval(ele.timer);            console.log("finish moving...");       } else {            curPos += speed;            ele.style[dir] = curPos + "px";       }    }, 20);    console.log("printing....");}let box = document.querySelector("#box");move(box, "left", 100);</code></pre><p>上述代码会产生下图效果：</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/code-result1.gif" alt="代码运行结果"></p><p>打印结果如下：</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/code-result2.png" alt="代码运行打印结果"></p><p>从运行结果可以看出，printing在方块移动结束前打印了，并没有像常规的程序那样顺序执行。这就是最基本的异步的实现。</p><h3 id="异步结束完需要操作怎么办？"><a href="#异步结束完需要操作怎么办？" class="headerlink" title="异步结束完需要操作怎么办？"></a>异步结束完需要操作怎么办？</h3><p>肯定有很多解决方法，但是我认为比较好的方法是回调函数的方法，修改上述代码：</p><pre><code>function move(ele, dir, dist, callback) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    clearInterval(ele.timer);    console.log("start moving...");    ele.timer = setInterval(() =&gt; {       if (Math.abs(curPos - dist) &lt;= 0) {            clearInterval(ele.timer);            console.log("finish moving...");            callback &amp;&amp; callback(); // ===&gt;此处先判断是否存在callback，如果存在就执行       } else {            curPos += speed;            ele.style[dir] = curPos + "px";       }    }, 20);    console.log("printing....");}let box = document.querySelector("#box");move(box, "left", 100, () =&gt; {    console.log("执行回调函数");});</code></pre><p> 上述代码执行结果是：</p><pre><code>start moving...printing....finish moving...执行回调函数</code></pre><p>这样就能很好的解决异步执行之后需要用到异步的结果或者需要执行某些代码的问题。</p><h3 id="这种实现异步和回调的问题：回调地狱"><a href="#这种实现异步和回调的问题：回调地狱" class="headerlink" title="这种实现异步和回调的问题：回调地狱"></a>这种实现异步和回调的问题：回调地狱</h3><p>所谓回调地狱，就是多次回调，致使层数过深，如下：</p><pre><code>move(box, "left", 100,() =&gt; {    move(box, "top", 100,() =&gt; {        move(box, "left", -100,() =&gt; {            move(box, "top", -100,() =&gt; {                console.log("finish...");            });        });    });});</code></pre><p>上述代码层数过深，不利于代码的复用性和阅读性。</p><h2 id="回调地狱解决办法"><a href="#回调地狱解决办法" class="headerlink" title="回调地狱解决办法"></a>回调地狱解决办法</h2><p>解决办法有三种，分别是使用<strong>Promise</strong> ，使用<strong>Async和Await</strong>以及使用<strong>Generator</strong>函数。这一篇文章先讲一下Promise的使用。</p><h3 id="Promise的概念以及使用"><a href="#Promise的概念以及使用" class="headerlink" title="Promise的概念以及使用"></a>Promise的概念以及使用</h3><p><strong><em>Promise不是解决异步问题本身，而是解决异步的写法问题，使异步写法更清晰。</em></strong></p><p>先说下Promise，在MDN，Promise被如下定义：</p><pre><code>Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.[1]</code></pre><p>Promise有三个状态：<b>Pending（在等待异步流程执行完毕）；Fulfilled或者Resolved（成功）；Rejected（失败）</b>。<br>异步操作的结果决定了当前状态，其它内容无法干扰Promise状态。且，Promise如果状态改变，则不会再变，比如从pending改变到rejected，就不会再回到pending，或者再变为fulfilled。[2]</p><p>接下来展示一段Promise的简单使用：</p><pre><code>let p = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            console.log(p);            resolve();        }, 2000);     });    p.then(() =&gt; {        console.log(p);        console.log("then....");    }); </code></pre><p>then方法就相当于之前实现多次异步时候的回调函数，根据上述代码，可以发现Promise创建后传入一个函数，函数的参数是两个函数resolve和reject，分别对应着rejected和resolved（fulfilled）两个状态。现在就一目了然了，如果异步执行成功，则调用运行resolve()，反之运行reject()。上述运行结果为：</p><p>程序运行两秒后，打印如下内容：</p><pre><code>Promise {&lt;pending&gt;}Promise {&lt;resolved&gt;: undefined}then....</code></pre><p>由此可见，如果异步执行成功，调用resolve函数，则程序会向下执行到then，而且从打印的两个p我们能看出，Promise的状态从pending向resolved改变。</p><h4 id="那如何使用异步结果呢？"><a href="#那如何使用异步结果呢？" class="headerlink" title="那如何使用异步结果呢？"></a>那如何使用异步结果呢？</h4><p>很多时候，异步产生的结果，是我们后面要使用的，那么如果像上述一样用Promise来优化异步的写法，我们如何使用异步结果呢？</p><p>其实答案已经在上述代码出现了。上述代码的打印结果的第二行，Promise状态resolved后面有一个undefined。这个地方，就是用来存异步结果的。代码可以改动如下：</p><pre><code>let p = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            console.log(p);            resolve("parameters..."); // =======》这里执行resolve时候可以传入参数。        }, 2000);  }); p.then((res) =&gt; { // ======》这里能传入一个参数，比如res        console.log(p);        console.log(res);                 console.log("then...."); });</code></pre><p>运行结果如下：</p><pre><code>Promise {&lt;pending&gt;}Promise {&lt;resolved&gt;: "parameters..."}parameters...then....</code></pre><p>结合上述代码和结果，我们能看出来，通过向resolve方法传入异步结果，在调用then方法后，可以接收一个参数，这个参数就指向异步的结果。从而就能使用异步结果了。</p><p>如果想在then函数中处理reject的结果，那么也很简单，传入第二个回调函数作为参数，比如：</p><pre><code>p.then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }, (rej) =&gt; {        console.log(rej); });</code></pre><p>一目了然，在此就不做赘述了。</p><p>但是如果存在需要链式调用then函数，每个函数中都传入两个函数来处理成功和失败的结果，有时候会比较繁琐，因此，如果所有步骤处理出现错误或者失败，都只需要返回一种信息给用户（比如网络请求错误），可以用以下办法：</p><pre><code>p.then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).catch((rej) =&gt; {     console.log("fail..."); })</code></pre><p>如果想实现之前那种需要多次回调的场景也很简单，代码如下：</p><pre><code>let po = new Promise((resolve, reject) =&gt; {    resolve(1);});po.then((res) =&gt; {   console.log(res);   return 2;}).then((res) =&gt; {   console.log(res);   return 3;}).then((res) =&gt; {   console.log(res);   return 4;}).then((res) =&gt; {   console.log(res);})</code></pre><p> 运行结果是：</p><pre><code>1234</code></pre><p>很显然，then方法最后return的结果是可以被后面的then方法获取到的。但是为什么能获取呢？我们可以给调用then方法的结果赋值，打印看下。代码为：</p><pre><code>let po = new Promise((resolve, reject) =&gt; {     resolve(1); }); let pt = po.then((res) =&gt; {     console.log(res);     return "pt"; }) console.log(pt);</code></pre><p> 结果为：</p><pre><code>Promise {&lt;pending&gt;}__proto__: Promise[[PromiseStatus]]: "resolved"[[PromiseValue]]: "pt"1</code></pre><p>上述代码运行后先打印了最后一行的pt。因为异步的原因，然后打印了resolve传入then函数的数字1。pt的展开结果我们可以看出，then方法会给我们返回一个Promise对象，而且从上述结果看出，返回的是一个resolved状态的Promise对象。</p><p>现在我们都了解到Promise的用法了，上文中的移动方块的例子能改写为：</p><pre><code>function move(ele, dir, dist) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    return new Promise((resolve, reject) =&gt; {        clearInterval(ele.timer);        ele.timer = setInterval(() =&gt; {        if (Math.abs(curPos - dist) &lt;= 0) {                clearInterval(ele.timer);                 resolve();        } else {                curPos += speed;                ele.style[dir] = curPos + "px";        }        }, 20);    })}let box = document.querySelector("#box");move(box, "left", 100).then(() =&gt; {    return move(box, "top", 100);}).then(() =&gt; {    return move(box, "left", 0);}).then(() =&gt; {    return move(box, "top", 0);})</code></pre><p>运行结果和上述结果一样。但是可读性和代码可扩展性得到了显著的提高。</p><h4 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise all方法"></a>Promise all方法</h4><p>说完Promise的使用和then还有catch常用方法，接着说下Promise的另一个常用方法 - all方法。</p><p>MDN对于all方法的说明是：</p><pre><code>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数    中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失    败原因的是第一个失败 promise 的结果。[3] </code></pre><p>简单说就是比如创建了三个不同的Promise对象，调用all方法执行三个Promise对象，如果三个都是resolved状态，则可以向下执行。</p><p>例子：</p><pre><code> let p1 = new Promise((resolve, reject) =&gt; {     console.log(1);     resolve(); });let p2 = new Promise((resolve, reject) =&gt; {     console.log(2);     resolve(); }); let p3 = new Promise((resolve, reject) =&gt; {     console.log(3);     resolve(); }); Promise.all([p1, p2, p3]).then(() =&gt;{     console.log(4); })</code></pre><p>结果：</p><pre><code>1234</code></pre><p>如果任意一个Promise对象的执行状态是rejected。则需要在then中或者或者代码最后使用catch方法捕获错误，不然会报错。</p><h3 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise race方法"></a>Promise race方法</h3><p>这个方法和all方法正好相反，all方法是全部执行结束，才执行下面的内容。race方法顾名思义，有其中一项执行结束，则开始执行下面的方法。代码如下：</p><pre><code> let p1 = new Promise((resolve, reject) =&gt; {     setTimeout(() =&gt; {        console.log(1);        resolve();     }, 2000); });let p2 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        console.log(2);        resolve();     }, 1000); }); let p3 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        console.log(3);        resolve();     }, 5000); }); Promise.race([p1, p2, p3]).then(() =&gt;{     console.log(4); }).catch(() =&gt; {     console.log("err"); });</code></pre><p>结果是：</p><pre><code>2413</code></pre><p>上面代码我们把p1的执行时间设置为2s，p2是1s，p3是5s，从结果就能看出，p1执行结束后，直接执行下面的then方法，因此打印顺序是2，4接着两个分别按照设定时间执行完毕。</p><h3 id="Async和Await写法"><a href="#Async和Await写法" class="headerlink" title="Async和Await写法"></a>Async和Await写法</h3><p>有时候用Promise的一系列方法，仍然感觉可读性一般，代码扩展性也有局限，那么这时候，可以用Async和Await结合Promise使用。示例代码如下：</p><pre><code>async function fn () {    let p1 = await new Promise((resolve) =&gt; {        console.log(1);        resolve(2);    });    let p2 = await new Promise((resolve) =&gt; {        console.log(p1);        resolve(3);    });    let p3 = await new Promise((resolve) =&gt; {        console.log(p2);        resolve(4);    });    console.log(p3);}fn();打印结果：1234</code></pre><p>Async和Await进一步简化了代码量，优化了写法，也是现今为止最常用的异步写法。<br>注意：</p><ol><li>Await 后面接一个能返回Promise对象的方法或者创建一个新Promise对象。</li><li>Await必须放在Async标示的函数当中。</li><li>如果需要捕获异常，可以用try{} catch (exception) {}，把await写入try后面的代码块中。</li><li>Async函数返回一个Promise，状态是resolved。</li><li>Await可接受非Promise作为await表达式的结果。但是不管await后面是什么，都会阻塞async函数内部代码执行，如果这时有外部代码，则先执行外部代码，之后再回到内部执行。</li><li>如果async中代码是同步代码，那就同步执行。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Promise差不多就说完了，也简单说了下Async和Await。感觉会用是最关键的。至于Generator，听说过没用过，感觉用的比较少，以后找机会再说吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p><p>[2] <a href="https://www.jianshu.com/p/1ab01ee4102a" target="_blank" rel="noopener">https://www.jianshu.com/p/1ab01ee4102a</a></p><p>[3] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6的一些知识点整理</title>
      <link href="/2020/01/02/es6_de_yi_xie_zhi_shi_dian_zheng_li/"/>
      <url>/2020/01/02/es6_de_yi_xie_zhi_shi_dian_zheng_li/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理</h1> </center><center> <h2> <font color="lightgray">基础部分</font> </h2> </center><font size="3"><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>接触前端也很久了，当然主要都是在学校，工业级的不太多，仅仅是实习中的有限的时间接触了一些。说到前端，不得不说前端的发展历程，从最简单的类似UI的工作，到现在，各种前端框架层出不穷，前端开发也从Web开发的无足轻重，变成现在和后端一样的重要。同样由于近几年Web前端技术的发展，IOS和Android技术被挤压的很厉害，也渐渐并入前端当中。使得现在前端在Web开发中占有的比重隐隐超过后端。</p><p>以上是我个人对前端变化的理解。排除Android和IOS，Web前端技术，不论你是用什么框架，什么库，JavaScript永远是基础，也是最重要的一部分。JavaScript主要由ECMAScript（核心），DOM（文档对象模型）和BOM（浏览器对象模型）。</p><p>ES6（ECMAScript 6）是2015年推出的，也推出一段时间了，随着这几年发展，添加了很多新特性，虽然后面还有ES2017，ES2019，但是貌似普及率没有ES6高，兼容性更不要说了，ES6保证了一定的向下兼容性，后面我会总结下ES6的一些新出的基础知识点，包括新增关键词，新增概念等。</p><h2 id="ES6的兼容性"><a href="#ES6的兼容性" class="headerlink" title="ES6的兼容性"></a>ES6的兼容性</h2><p>首先先说ES6的兼容性，ES6支持绝大多数最新版本浏览器，包括Edge，Firefox 68+， Chrome 78+，Opera65+，Safari 12.1+等桌面版浏览器支持率几乎达到100%。移动版浏览器，包括IOS12+，Samsung 9+， OperaMobile 54+兼容程度也接近100%。至于IE，就基本不支持了，但是可以用代码转换。</p><h3 id="ES6兼容IE（和其它浏览器）的方法"><a href="#ES6兼容IE（和其它浏览器）的方法" class="headerlink" title="ES6兼容IE（和其它浏览器）的方法"></a>ES6兼容IE（和其它浏览器）的方法</h3><ol><li>兼容基本语法（不包括Promise之类的）</li></ol><p>在引入其它脚本前，引入browser.min.js， script标签的type设为text/babel</p><ol start="2"><li>如果使用Promise等新特性</li></ol><p>Babel默认编译转换JavaScript语句，不能转换新的API。但是可以使用Polyfill（代码填充）技术。在开发页面中引入browser-polyfill即可：</p><pre><code>&lt;script type="text/javascript" src="你的browser-polyfill路径"&gt;&lt;/script&gt;</code></pre><h2 id="let，const的使用以及它们和var的区别"><a href="#let，const的使用以及它们和var的区别" class="headerlink" title="let，const的使用以及它们和var的区别"></a>let，const的使用以及它们和var的区别</h2><p>let和const是ES6新出来的关键字，和var作用相同，用来声明变量。但是也有很多不同。如果需要考虑兼容性更多，还是推荐用var比较好。接下来说下它们的使用和区别。</p><h3 id="说let和const之前，先说说var的一些特性"><a href="#说let和const之前，先说说var的一些特性" class="headerlink" title="说let和const之前，先说说var的一些特性"></a>说let和const之前，先说说var的一些特性</h3><ul><li><p>var的作用域是全局或者整个函数块</p></li><li><p>var可以被预解析，也就是说，可以在定义前使用变量，比如：</p><p>  <code>console.log(a); var a = 10;</code>这个是不会报错的，因为var定义的a被预解析。</p></li><li><p>var定义的变量在同一作用域下能重复定义</p><p>  <code>var a = 10; console.log(a); var a = 20; console.log(20);</code> 结果是10 20</p></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>let声明的变量或者语句以及表达式，作用域为块级作用域（简单粗略可以理解成是两个大括号包裹着是一个块级作用域）</p></li><li><p>同一作用域下，let不能重复声明，比如：</p><p>  <code>let a = 10; console.log(a); let a = 20;</code> 上述代码会报错，因为在同一个作用域中重复声明了a变量。</p></li><li><p>let不能被预解析，也就是：</p><p>  <code>console.log(a); let a = 10;</code>是会报错的。</p></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 就没什么可说的了，它拥有let的所有特性，并且定义的变量为常量，不可重复赋值。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>let，const和var基本介绍完了，很简单，let和const的出现，优化了声明变量，表达式等。如果不考虑兼容性，推荐使用let代替var。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.jianshu.com/p/13444c467ce2" target="_blank" rel="noopener">https://www.jianshu.com/p/13444c467ce2</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla</a></li></ul></font><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一个博客 - 新起点</title>
      <link href="/2019/11/23/wo_de_di_yi_ge_bo_ke_xin_de_kai_shi/"/>
      <url>/2019/11/23/wo_de_di_yi_ge_bo_ke_xin_de_kai_shi/</url>
      
        <content type="html"><![CDATA[<center> <h1>我的第一个博客</h1> </center><center> <h2> <font color="lightgray">新起点</font> </h2> </center><font size="4">您好，我是Kingsley。我于2019年5月10日毕业于南加州大学（USC）。我的专业是计算机科学。我现在仍在找美国的全职软件工程师职位。<p>在本科学习和硕士学习期间，我已经学习计算机科学超过五年了。我在英国获得了本科学位。我的大学是埃塞克斯大学。它位于英国最古老的城镇-科尔切斯特。</p><p>在这几年中。我学到了很多不同类型的技术栈。例如，Java，Spring，Python，Django，HTML，CSS，JavaScript，Vue.js，React.js，Angular，MySQL，Redis和属于其他技术领域的技术。我的知识足够广泛。但是我需要找出这些技术的未来职业方向。而且我需要深入学习相关技术。</p><p>因此，我建立并部署了此个人博客。我希望记录下我需要记住的知识点，在开发项目期间遇到的错误以及对所学技术的个人理解。</p><p>我目前的计划是修正和复习有关Java的知识，记录要点，学习期间发生的错误等。</p><p>将来，我将复习和修正越来越多我以前学过的的技术的要点。</p><p>谢谢。</p><p>K.L<br></p></font><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 一些感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 琐碎杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
