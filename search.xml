<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重学操作系统（七）</title>
      <link href="2021/05/31/chong_xue_cao_zuo_xi_tong_qi/"/>
      <url>2021/05/31/chong_xue_cao_zuo_xi_tong_qi/</url>
      
        <content type="html"><![CDATA[<h2 id="重学操作系统（七）"><a href="#重学操作系统（七）" class="headerlink" title="重学操作系统（七）"></a><center>重学操作系统（七）</center></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天继续学习记录关于操作系统这个课程。这一章节是Linux权限划分相关的知识点。我们最熟悉的，每次运行某些命令，会提示permission denied。这就代表当前用户没权限，这样我们加上sudo去运行，就可以了。</p><blockquote><p>Tips: sudo命令在维基百科的解释是substitute user [或 superuser] do。</p></blockquote><hr><h3 id="贯穿全文的一道题：简述Linux权限划分原则？"><a href="#贯穿全文的一道题：简述Linux权限划分原则？" class="headerlink" title="贯穿全文的一道题：简述Linux权限划分原则？"></a><em><strong>贯穿全文的一道题：简述Linux权限划分原则？</strong></em></h3><hr><h3 id="权限抽象"><a href="#权限抽象" class="headerlink" title="权限抽象"></a>权限抽象</h3><p>一个完整的权限管理体系，要有合理的抽象，包括对用户，进程，文件，内存，系统调用等抽象。</p><h4 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a><strong>用户和组</strong></h4><p>Linux是多用户平台，允许多个用户同时登录系统。Linux将用户抽象为账户。账户可以登录系统。</p><p>为了方便分配用户权限，Linux支持组（Group）账户。组账户是很多用户账户的集合，组可以为成员分配某一类权限，一个用户可以在多个组。</p><p>Root账户，也叫超级管理员，对系统有着完全的掌控。一个root账户，可以使用系统提供的所有能力。</p><h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a><strong>文件和目录</strong></h4><p>Linux对文件和目录（目录也是一种文件）进行了权限抽象，Linux对于文件有以下三个权限：</p><pre><code>1. 读权限（r）：控制读取文件2. 写权限（w）：控制写入文件3. 执行权限（x）：控制文件执行</code></pre><p>以上每个权限，可以从用户，组，全部用户三个维度区进行配置：</p><pre><code>文件权限一般是类似下述：- rwx rwx rwx第一位是file type，"-"是文件，"d"是目录，"p"是管道文件后面三位三位分别对应三个维度的读写执行权限，如果是rwx，则拥有读写执行权限，如果比如"r--"，就是拥有只读权限，没有的权限用"-"来表示</code></pre><h4 id="初始权限"><a href="#初始权限" class="headerlink" title="初始权限"></a><strong>初始权限</strong></h4><p>一个文件创建后，文件所属用户被设置成创建文件的用户。Linux会为每个用户创建一个同名分组，如果用户想要切换分组，执行newgrp指令切换。因此被创建的文件属于用户所在的分组，因此一般情况，文件创建后权限是：</p><blockquote><p>rw-rw-r–</p></blockquote><p>用户和组维度可读写，所有用户可读。</p><h4 id="类似ls这种指令文件的权限"><a href="#类似ls这种指令文件的权限" class="headerlink" title="类似ls这种指令文件的权限"></a><strong>类似ls这种指令文件的权限</strong></h4><p>废话不多说，先看图！！！</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/ReviewOS/cxczxt7-1.png" alt="ls -l运行结果" title="ls -l运行结果"></p><p>上图是在”/usr/local/bin”中运行”ls -l”的结果，从结果看，这些指令文件的权限都是一样的，都是用户维度的可读写执行，组和全部用户维度都是可读可执行。它们都属于root用户，wheel组（组名可能是系统不同组名不同）。</p><blockquote><p>Tips: 如果一个文件不可读，可执行，那么这个文件也无法执行。</p></blockquote><h4 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a><strong>执行文件</strong></h4><p>Linux中，可以通过”echo $PATH”查看可执行文件都在哪些目录中。PATH就是Linux的环境变量。</p><h4 id="内核和系统调用权限"><a href="#内核和系统调用权限" class="headerlink" title="内核和系统调用权限"></a><strong>内核和系统调用权限</strong></h4><p>内核提供操作硬盘，磁盘，内存分页，进程等最核心的能力。并拥有直接操作全部内存的权限。因此内核不能把自己的全部能力提供给用户，也不能允许用户通过shell指令进行系统调用。Linux把部分进程需要的系统调用以API的形式暴露出来，部分系统调用需要进行权限检查。</p><h3 id="权限架构思想"><a href="#权限架构思想" class="headerlink" title="权限架构思想"></a>权限架构思想</h3><p>权限架构的主要目标是让系统安全，稳定且用户，程序之间相互制约，相互隔离。因此优秀的架构，应该遵循最小权限原则（Least Privilege）。此外，权限架构应该还遵循一个原则，权限划分边界应该足够清晰，尽量相互隔离。</p><h4 id="分级保护"><a href="#分级保护" class="headerlink" title="分级保护"></a><strong>分级保护</strong></h4><p>内核可以直接操作内存和CPU，驱动程序能直接控制摄像头，显示屏等核心设备，因此它们需要采取安全措施。一般操作系统采取环状保护模式。</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/ReviewOS/cxczxt7-2.png" alt="分级保护" title="分级保护"></p><p><em><strong></strong></em></p><center><em><strong>图片来源于参考中的链接</strong></em></center><p></p><p>上图就能看出，越往内层，权限级别越高。最外层是应用权限层，中间两层是设备驱动权限层，中间是内核权限层。</p><h4 id="权限包围（Privilege-Bracking）"><a href="#权限包围（Privilege-Bracking）" class="headerlink" title="权限包围（Privilege Bracking）"></a><strong>权限包围（Privilege Bracking）</strong></h4><p>Linux提供一一个能力，比如有一个应用需要临时使用高级权限，可以验证身份通过后，赋予临时高级权限，当这个应用执行完相应的操作，马上恢复为普通权限。这样能做到减少应用在高级权限的时间，做到专权专用，防止被恶意程序利用。</p><h3 id="用户分组指令"><a href="#用户分组指令" class="headerlink" title="用户分组指令"></a>用户分组指令</h3><ul><li><p>groups指令：查看当前用户的所有分</p></li><li><p>id指令：查看当前用户</p><p>  <img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/ReviewOS/cxczxt7-3.png" alt="id运行结果" title="id运行结果"></p><p>  其中，uid是当前用户id，gid是组id，groups后面的是每个分组和分组id。</p></li><li><p>cat /etc/passwd：查看所有用户信息</p><p>  <img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/ReviewOS/cxczxt7-4.png" alt="id运行结果" title="id运行结果"></p><p>  以root这一行来看：</p><p>  root:*:0:0:System Administrator:/var/root:/bin/sh</p><ul><li>root：用户名</li><li>*：密码</li><li>0: uid</li><li>0: gid</li><li>System Administrator：userId信息</li><li>/var/root：家目录</li><li>/bin/sh：shell路径</li></ul></li><li><p>useradd：创建用户</p></li><li><p>groupadd：创建分组</p></li><li><p>usermod -a -G sudo 【用户名】：<br>组分为主要分组（Primary Group）和次级分组（Secondary Group），主要分组只有一个，次级分组可以有多个。usermod的作用是给用户添加次级分组。比如上面命令就是给【用户名】添加到sudo分组，从而使其有sudo的权限。</p></li></ul><blockquote><p>Tips: -a = append, -G = 次级分组清单</p></blockquote><ul><li>usermod -g somegroup 【用户名】：修改用户主要分组</li></ul><h3 id="文件权限管理指令"><a href="#文件权限管理指令" class="headerlink" title="文件权限管理指令"></a>文件权限管理指令</h3><ul><li><p>chmod：修改文件权限</p><blockquote><p>chmod +x [文件名]</p></blockquote><blockquote><p>chmod -x [文件名]</p></blockquote><blockquote><p>chmod +rwx [文件名]</p></blockquote><blockquote><p>chmod 467 [文件名]（467 =》二进制是100 110 111，对应：用户权限 - 组权限 - 所有用户权限的rwx，r– rw- rwx）</p></blockquote></li><li><p>chown：修改文件所属用户，比如：</p><p>  chown user1 ./file =&gt; 将file文件修改为user1用户</p><p>  或者</p><p>  chown group1.user1 ./file =&gt; 将file文件所属用户和分组改为group1分组下的user1用户。</p></li></ul><p>以上是多种修改文件权限的方式。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一章学了很多惯用语Linux权限的，很多之前不明白的操作，终于明白了。而且最关键的是，权限这方面的知识点，之前面试竟然遇到了，很庆幸看了这个章节。</p><p><em><strong>回到前面的问题，Linux权限的划分原则？</strong></em></p><p>答案显而易见，就是Linux遵循最小权限原则，每个用户和组掌握的权限应该足够小，应用应当尽可能小的使用权限。尽量少用root。系统层面，通过实现分级保护实现权限的划分。</p><p>如果一个目录是只读权限，对于root用户，读写执行操作都没问题。但是对于普通用户，则无法进入目录。</p><p><em><strong>目录的可执行权限的作用</strong></em></p><ol><li>进入目录</li><li>访问内部文件</li><li>对目录底下清单的修改，如增加，修改文件名，删除等</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4614">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4614</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 相关原理 </tag>
            
            <tag> 图灵机 </tag>
            
            <tag> 冯诺伊曼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学操作系统（六）</title>
      <link href="2021/05/31/chong_xue_cao_zuo_xi_tong_liu/"/>
      <url>2021/05/31/chong_xue_cao_zuo_xi_tong_liu/</url>
      
        <content type="html"><![CDATA[<h2 id="重学操作系统（六）"><a href="#重学操作系统（六）" class="headerlink" title="重学操作系统（六）"></a><center>重学操作系统（六）</center></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过上一篇文章，帮助我巩固了Linux一些简单的命令的使用和原理。接下来，后面这个文章，介绍些和进程，重定向，以及管道指令相关的事情。</p><hr><h3 id="贯穿全文的问题：xargs指令的作用是什么？"><a href="#贯穿全文的问题：xargs指令的作用是什么？" class="headerlink" title="贯穿全文的问题：xargs指令的作用是什么？"></a><em><strong>贯穿全文的问题：xargs指令的作用是什么？</strong></em></h3><hr><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>应用的可执行文件是在文件系统中，当执行的时候，会在操作系统中（内存）形成一个应用副本，这个副本就是进程。</p><h3 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a><strong>什么是进程？</strong></h3><blockquote><p>定义：进程是应用的副本<br>作用：进程是操作系统分配资源的最小单位</p></blockquote><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看当前进程，p代表processes（进程），s代表snapshot（快照）。</p><blockquote><p>TTY：过去用来传递信息，现在可以指代传真，邮件，微信等。</p></blockquote><p>操作系统上的TTY是一个输入输出终端的概念，比如用户打开一个bash，操作系统就为用户分配一个输入输出终端。没有加任何参数的ps只显示在同一个TTY的进程。</p><ol><li><p>ps -e：用来显示所有进程，-e没有特殊含义，只为了和-A区分开。通常用ps -ef比较多，-f的作用是显示更多描述信息。</p><p> <img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/ReviewOS/chongxuecaozuoxitong6-1.png" alt="ps -e输出结果" title="ps -e输出结果"></p><p> <strong></strong></p><center><strong>ps -e 输出结果</strong></center><p></p><p> <img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/ReviewOS/chongxuecaozuoxitong6-2.png" alt="ps -ef输出结果" title="ps -ef输出结果"></p><p> <strong></strong></p><center><strong>ps -ef 输出结果</strong></center><p></p><p> 从上面两个图片可以看出，ps-ef显示更多的信息，包括（从左到右）：</p><ol><li>UID：进程所有者</li><li>PID：进程唯一标识</li><li>PPID：进程的父进程ID</li><li>C：CPU利用率（CPU占用）</li><li>STIME：开始时间</li><li>TTY：进程所在TTY，如果没有，是？</li><li>TIME</li><li>CMD：进程启动时命令，如果不是Shell命令，用方括号括起来，那就是系统进程或者内核进程</li></ol></li><li><p>ps aux：功能类似ps -e，但是是BSD（加州伯克利分校）研发的UNIX分支版本的衍生风格，如下：</p><p> <img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/ReviewOS/chongxuecaozuoxitong6-3.png" alt="ps -ef输出结果" title="ps -ef输出结果"></p><p> <strong></strong></p><center><strong>ps aux 输出结果</strong></center><p></p></li></ol><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top能力和ps差不多，但是显示的不是快照，而是实时更新数据。</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/ReviewOS/chongxuecaozuoxitong6-4.png" alt="top" title="top"></p><p> <strong></strong></p><center><strong>top 输出结果</strong></center><p></p><h2 id="管道（Pipeline）"><a href="#管道（Pipeline）" class="headerlink" title="管道（Pipeline）"></a>管道（Pipeline）</h2><p>管道的作用，是在命令和命令之间，传递数据。比如一个命令的结果，可以作为另一个命令的输入。这里的命令就是进程，因此管道可以说，是在进程间传递数据。</p><h3 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h3><p>每个进程都有自己的标准输入流，标准输出流和标准错误流。根本上来说，这几个标准流都是文件。</p><ol><li>标准输入流（用0表示）：可以作为进程执行的上下文</li><li>标准输出流（用1表示）：写入的结果会被打印到屏幕上</li><li>标准错误流（用2表示）：如果在进程执行过程中，发生异常，那么异常信息就会被记录到标准错误流中</li></ol><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向符号的作用是，将标准输出流输出的结果，重定向到一个文件中。</p><blockquote><p>‘&gt;’符号：覆盖重定向<br>‘&gt;&gt;’符号：追加重定向<br>比如：ls -l &gt; out，将ls -l的输出，写入out文件，如果out文件是有内容，则覆盖。<br>start.sh &gt;&gt; logfile，将运行日志追加进logfile中<br>ls1 &gt; out，这个结果不会存入out，因为ls1指令不存在<br>ls1 &amp;&gt; out，写法等价于，ls1 &gt;out 2 &amp;&gt;1，重定向标准错误流<br>&amp;代表引用关系，在上述中代表了ls1 &gt; out的标准输出流</p></blockquote><h3 id="管道的作用和分类"><a href="#管道的作用和分类" class="headerlink" title="管道的作用和分类"></a>管道的作用和分类</h3><p>管道和重定向很像，但是管道是一个连接一个计算，重定向是将一个文件的内容，定向到另以恶搞文件。</p><p>Linux中，管道也是文件，其中有两种类型：</p><ul><li>匿名管道（Unnamed Pipline），这种管道也在文件系统中，它只是一个存储节点，不属于任何目录（没有路径）</li><li>命名管道（Named Pipline），这种管道就是一个文件，有自己的路径</li></ul><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>管道具有FIFO的特性，所以先进入管道的数据，先传递到管道的下游。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p>Linux提供了’|’作为管道符，’|’左面的输出结果会作为右面的输入结果。</p></blockquote><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h4><p>比如使用ls，希望按照文件名排序倒序，可以使用匿名管道，将ls的结果传给sort指令。</p><blockquote><p>ls | sort -r （-r是reverse）</p></blockquote><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a><strong>去重</strong></h4><p>去重可以使用uniq指令，uniq指令查找文件中相邻的重复行，然后去重，但是如果重复行是交替的，就不能直接uniq，可以先sort然后利用管道，将sort结果重定向到uniq指令。</p><blockquote><p>sort text.txt | uniq</p></blockquote><h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a><strong>筛选</strong></h4><p>筛选可以利用grep结合管道，比如</p><blockquote><p>find ./ | grep Spring 查找当前路径下所有包含Spring关键字<br>（Tips: find的作用是在所指定路径中递归查找文件）<br>grep -v xxx 查找不包含xxx的结果</p></blockquote><h4 id="计算行数"><a href="#计算行数" class="headerlink" title="计算行数"></a><strong>计算行数</strong></h4><ol><li>如果想知道一个文件中有多少行，可以用wc -l 文件名</li><li>如果想知道目录下有多少文件，用ls ｜ wc -l</li><li>如果计算一个java项目的目录中，有多少行代码，可以用：find -i ‘.java’ ./ | wc -l</li></ol><h4 id="中间结果"><a href="#中间结果" class="headerlink" title="中间结果"></a><strong>中间结果</strong></h4><p>如果多个管道相连，我们想保存下中间的结果，就需要用到tee指令。tee指令从标准输入流中读取数据到标准输出流。tee的另一个作用是，在这个过程中，把输入流的数据存到文件中，比如：</p><pre><code>find ./ -i "*.java" | tee JavaList | grep Spring这个指令的意思是，在当前目录找到所有Spring关键字的Java文件，tee本身不影响指令的执行，但是tee会把find的结果存到JavaList文件中。tee就像T，连接通道两端，下面开了个口，这个开口在函数式编程，叫副作用。</code></pre><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a><strong>xargs</strong></h4><p>xargs指令，从标准数据流中构造并执行一行行的指令。xargs从输入流获取字符串，利用空白，换行符等切割字符，在这些字符串的基础上，构造指令，最后一行行的执行这些指令。</p><pre><code>比如要重命名x.a，y.a，z.a三个文件，想在它们前面都加上prefix_前缀，就可以用xargs。假设它们三个在一个文件夹中，并且文件夹中没有其它文件，可以直接用指令：ls | xargs -I FILE mv FILE prefix_FILE这里，FILE是指代ls查找的所有文件名，-I是查找替换符。样板代码：如果上述例子，不用xargs，那么我们需要自己敲代码完成文件的重命名：    mv x.a prefix_x.a    mv y.a prefix_y.a    mv z.a prefix_z.a这就是样板代码</code></pre><h3 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h3><p>命名管道文件是要在文件夹中，有自己的路径，因此需要创建。可以使用mkfifo指令创建命名管道，比如mkfifo pipe1。明明管道和匿名管道能力类似。</p><p>比如我们创建一个命名管道叫pip，如果这时候用cat pip，则不打印任何东西。</p><blockquote><p>Tips: cat指令的作用是，将文件内容打印到屏幕</p></blockquote><p>之后如果执行 echo ‘abc’ &gt; pip，将abc写入pip，屏幕中会打印abc</p><blockquote><p>Tips: 可以使用cat pip &amp;指令，&amp;的意思是后台执行，这样就不会阻塞用户继续输入。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇文章的内容，对于我来说，是全新的，帮助我加深了对Linux命令的了解，也更加清晰，一些常见命令，比如grep，cat等和其它命令通过’|’连接，具体是如何执行的，并且原理是什么。目前这个主题的文章看到这，我已经惊叹不已，基本把我对计算机原理，Linux基础命令的漏洞，都补充上了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4613">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4613</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 相关原理 </tag>
            
            <tag> 图灵机 </tag>
            
            <tag> 冯诺伊曼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学操作系统（五）</title>
      <link href="2021/05/31/chong_xue_cao_zuo_xi_tong_wu/"/>
      <url>2021/05/31/chong_xue_cao_zuo_xi_tong_wu/</url>
      
        <content type="html"><![CDATA[<h2 id="重学操作系统（五）"><a href="#重学操作系统（五）" class="headerlink" title="重学操作系统（五）"></a><center>重学操作系统（五）</center></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上面几篇文章，学习了关于计算机的基本理论，计算机原理，底层一些知识点。也算为我打开一扇大门。其中很多知识点和思想，都是曾经没学到的。之前几篇文章，让我受益匪浅。接下来几篇是介绍Linux指令相关的。Linux指令在面试中，不一定都会问到，但是就我的经验，问到后，答得越多，越准确，是十分加分的一项，尤其是社招。</p><hr><h3 id="贯穿全文的问题：rm-rf什么意思？"><a href="#贯穿全文的问题：rm-rf什么意思？" class="headerlink" title="贯穿全文的问题：rm / -rf什么意思？"></a><em><strong>贯穿全文的问题：rm / -rf什么意思？</strong></em></h3><hr><h3 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h3><p>简单来说，就是一个命令行的用户界面。</p><blockquote><p>Bash：Bourne Again Shell，是Shell的组成程序。由Steve Bourne发明的。</p></blockquote><h3 id="Linux对文件目录的抽象"><a href="#Linux对文件目录的抽象" class="headerlink" title="Linux对文件目录的抽象"></a>Linux对文件目录的抽象</h3><p>Linux对文件进行了一个树状的抽象。/代表根目录，每一层目录用/分开。</p><h3 id="路径（Path）"><a href="#路径（Path）" class="headerlink" title="路径（Path）"></a>路径（Path）</h3><p>路径就是一个文件在文件系统的地址。目标文件的绝对目录（Absolute Path），也叫完全路径（Full Path），是从/开始，接下来每一层都是一级子目录，直到定位到目标文件为止。</p><h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><p>Shell抽象出得目录。相对路径是以工作目录为基点的路径比如如果在/usr目录内，rm文件的相对路径是bin/rm。</p><blockquote><p>.代表当前目录，..代表上级目录。</p></blockquote><p>cd指令（Change Directory）：切换工作路径，既可以是绝对路径，也可以是相对路径。</p><blockquote><p>cd（不加参数）：回到home</p></blockquote><blockquote><p>cd .：什么都不发生</p></blockquote><blockquote><p>cd..：返回上级目录</p></blockquote><blockquote><p>pwd：查看当前目录</p></blockquote><h3 id="几种常见的文件类型"><a href="#几种常见的文件类型" class="headerlink" title="几种常见的文件类型"></a>几种常见的文件类型</h3><ol><li>普通文件（比如文本文件）</li><li>目录文件（特殊文件，存储文件清单，/也是一个文件）</li><li>可执行文件（rm这种命令文件就是可执行文件）</li><li>管道文件</li><li>socket文件</li><li>软链接文件（相当于指向另一个文件所在路径的符号）</li><li>硬连接文件（指向另一个文件的指针）</li></ol><blockquote><p>ls -F 可以看到当前目录下文件和它的类型：</p><ol><li>*结尾是可执行文件</li><li>=结尾是socket文件</li><li>@结尾是软链接</li><li>｜结尾是管道文件</li><li>没有符号的是普通文件</li><li>/结尾是目录文件</li></ol></blockquote><h3 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h3><p>Socket是网络插座，是客户端和服务端之间同步数据的接口。 Linux把设备抽象成文件，因为设备和操作系统交换数据就是有读，写两个操作。类似文件的操作。Linux把设备，如打印机，显卡等抽象成文件，使文件系统设计变得统一。</p><h3 id="文件的增删改查"><a href="#文件的增删改查" class="headerlink" title="文件的增删改查"></a>文件的增删改查</h3><blockquote><p>tips: man [指令] 可以查看相应指令的帮助，man是manual。比如man rm，man touch等。</p></blockquote><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a><strong>增加</strong></h4><ol><li>touch：用来改变时间戳，但是如果没有文件，就会创建文件。</li><li>mkdir： 创建目录（mkdir 目录名）</li><li>mkdir -p：递归创建，比如创建A/B/C</li></ol><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a><strong>查看</strong></h4><ol><li>ls： list缩写，查看文件夹内容</li><li>ls -l： 展示详细信息，比如权限，大小，修改时间</li><li>ls -a：显示所有</li><li>ls -al：显示所有的详细信息</li></ol><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h4><ol><li>rm：删除文件</li><li>rm -r：递归删除，删除目录</li><li>rm -f:强制删除，-f force（删除不给提示）</li></ol><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a><strong>修改</strong></h4><ol><li>nano，vim：Linux自带编辑器</li></ol><h3 id="查阅文件内容"><a href="#查阅文件内容" class="headerlink" title="查阅文件内容"></a>查阅文件内容</h3><ol><li>cat：适合浏览比较小的文件，比如配置文件。cat指令将文件连接到标准输出流并打印到屏幕</li><li>标准输出流（Standard Output）也是一种文件。</li><li>more：定位是一个阅读过滤器，可以支持翻页，也支持文本搜索</li><li>less：和more类似，less支持向上翻页，因此less用途比较多</li><li>head/tail：head和tail是一组，他们读取头部N行或者尾部N行（tail -n 1000）</li><li>tail -f：f是follow，会自动输出追加的内容（tailf）</li><li>grep：g = global，re = regular expression，p = pattern，所以它的作用是通过正则全局搜索一个文件找到的匹配模式<ol><li>grep [一段ip] ./nginx_logs.txt</li><li>grep [一个时间（20/April/2021:19:20）] ./nginx_logs.txt</li></ol></li></ol><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><ol><li>which：文件所在位置（which grep =》返回grep指令文件所在位置）</li><li>find：在文件系统中查找文件（find / -iname “*.txt”， -iname是用来匹配查找，i忽略大小写，-name是不忽略大小写）</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>全文下来，收获很丰富，了解了很多知道，但是知之不深的一些指令。回到前面的问题，rm -rf /，会删除根目录及其下所有文件和文件夹，并不给任何提示。所以不要乱用啊～～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4612">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4612</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 相关原理 </tag>
            
            <tag> 图灵机 </tag>
            
            <tag> 冯诺伊曼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学操作系统（四）</title>
      <link href="2021/05/31/chong_xue_cao_zuo_xi_tong_si/"/>
      <url>2021/05/31/chong_xue_cao_zuo_xi_tong_si/</url>
      
        <content type="html"><![CDATA[<h2 id="重学操作系统（四）"><a href="#重学操作系统（四）" class="headerlink" title="重学操作系统（四）"></a><center>重学操作系统（四）</center></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章，记录下存储器相关的一些知识，涉及到L1 Cache，SSD，内存的一些问题。接下来还是贯穿全文的一个问题</p><h3 id="SSD、内存和-L1-Cache-相比速度差多少倍？"><a href="#SSD、内存和-L1-Cache-相比速度差多少倍？" class="headerlink" title="SSD、内存和 L1 Cache 相比速度差多少倍？"></a><em><strong>SSD、内存和 L1 Cache 相比速度差多少倍？</strong></em></h3><h2 id="存储器分级"><a href="#存储器分级" class="headerlink" title="存储器分级"></a>存储器分级</h2><h3 id="为什么有存储器分级策略"><a href="#为什么有存储器分级策略" class="headerlink" title="为什么有存储器分级策略"></a>为什么有存储器分级策略</h3><p>因为我们希望的存储器是，体积小，空间大，功耗低，散热好，速度快。但是这种存储器是不存在的，现阶段，没有存储器能同时满足所有优点。</p><h3 id="存储器分级策略"><a href="#存储器分级策略" class="headerlink" title="存储器分级策略"></a>存储器分级策略</h3><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/cunchuqifenji.png" alt="存储器分级" title="存储器分级"></p><center>图片来源于参考一</center><p>上图很明显看出，存储器主要分6级。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p>紧挨着CPU的控制单元和逻辑单元，所使用的材料也是最快的。存储速度快，能耗高，产热大，花费高。所以数量不能很多。</p><blockquote><p>32位CPU中寄存器大多能存4个字节的内容</p></blockquote><blockquote><p>64位CPU中寄存器大多能存8个字节的内容</p></blockquote><p> 寄存器访问很快，一般要求半个CPU周期内完成读写。</p><h3 id="L1-Cache"><a href="#L1-Cache" class="headerlink" title="L1-Cache"></a><strong>L1-Cache</strong></h3><blockquote><p>L1 缓存在CPU中，虽然它离CPU更近，但是它造价低，通常L1缓存大小在几十Kb到几百Kb，读写速度大概是2-4个CPU周期。</p></blockquote><h3 id="L2-Cache"><a href="#L2-Cache" class="headerlink" title="L2-Cache"></a><strong>L2-Cache</strong></h3><blockquote><p>L2缓存也在CPU中，但是比L1缓存离CPU远。它大小比L1缓存大，能达到几M，速度是10 - 20个CPU周期。</p></blockquote><h3 id="L3-Cache"><a href="#L3-Cache" class="headerlink" title="L3-Cache"></a><strong>L3-Cache</strong></h3><blockquote><p>L3缓存在CPU中，比L2缓存离CPU更远。大小通常大于L2缓存，可以达到十几或者几十M，读写时间是20 - 60个CPU周期。</p></blockquote><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a><strong>内存</strong></h3><blockquote><p>内存主要材料是半导体硅，主要插在主板上，距离CPU有一定的距离，需要总线，才能和CPU连接。它体积大，造价远低于前面的存储器。内存可以达到几G到几T这个范围的存储空间。它的读写速度是200 - 300个CPU周期</p></blockquote><h3 id="SSD和硬盘"><a href="#SSD和硬盘" class="headerlink" title="SSD和硬盘"></a><strong>SSD和硬盘</strong></h3><blockquote><p>SSD：固态硬盘，结构类似内存，但是断电后数据能保存。内存，缓存，寄存器，断电后数据消失。内存读写速度比SSD快了10 - 1000倍，而比硬盘快了大概100万倍。因此SSD逐渐取代硬盘。</p></blockquote><p>当CPU需要内存中的某个数据，查询流程是：</p><blockquote><p>寄存器（如果没有）-&gt; L1缓存（如果没有）-&gt; L2缓存（如果没有）-&gt; L3缓存（如果没有）-&gt;内存</p></blockquote><h3 id="缓存条目结构"><a href="#缓存条目结构" class="headerlink" title="缓存条目结构"></a>缓存条目结构</h3><p>无论内存还是缓存，都是线性存储器，数据一个挨着一个存储。如果内存是一列表格，那么缓存是一个多列表格，每个表格中的每一行，叫做缓存条目。</p><blockquote><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3></blockquote><blockquote><p>数学方法：<br>比如100个内存地址，但是10个缓存条目。内存地址编号0 - 999，缓存条目编号0 - 9。比如701编号的内存，用数学方法，通过”地址 % 缓存条目数”这种方式，确定它的缓存条目。</p></blockquote><h3 id="指令预读"><a href="#指令预读" class="headerlink" title="指令预读"></a>指令预读</h3><p>由于CPU执行指令速度很快，一般2 - 6个周期能执行完毕，但是CPU读取内存速度，要200 - 300个周期，因此，CPU不能在内存中读一条指令就执行，如果这样，每个指令执行要200 - 300个周期。</p><blockquote><p>解决方法：<br>将L1缓存分为指令区和数据区，为了避免数据缓存覆盖指令缓存。然后CPU把内存中的指令预读几十或者上百条，存到L1缓存。L1缓存读写速度是2 - 4个周期，因此可以跟上指令执行的速度。L2和L3不协助处理指令预读的问题，因此它们不需要被分为指令区和数据区。</p></blockquote><h3 id="缓存的命中率"><a href="#缓存的命中率" class="headerlink" title="缓存的命中率"></a>缓存的命中率</h3><p>和缓存命中相反的是，miss，缓存穿透。一般三级缓存的命中率在95%，只有大概5%的内存读取会穿透。</p><h3 id="缓存置换"><a href="#缓存置换" class="headerlink" title="缓存置换"></a>缓存置换</h3><p>L1缓存满了，再次读内存，需要将旧条目移除，新条目存入，就叫缓存置换。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到开头的问题，我们可以得到，内存比SSD快10 - 1000倍，L1 Cache比内存快100倍。因此L1 Cache比SSD快1000 - 100000倍。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>假设有一个二维数组，共有1M个条目，如果遍历数组，是逐行遍历还是逐列遍历？</strong><br>Answer：<br>逐行遍历，因为二维数组是每行是一个一维数组。元素存在一维数组内是连续的，因此逐行遍历，能一次将这些连续地址加载到缓存，提高了缓存命中率。并且逐行遍历，内存页交换次数会增加很多（最差情况，每遍历一个元素就交换一次）。这种情况可以通过增大物理内存解决。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4610">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4610</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 相关原理 </tag>
            
            <tag> 图灵机 </tag>
            
            <tag> 冯诺伊曼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学操作系统（三）</title>
      <link href="2021/05/31/chong_xue_cao_zuo_xi_tong_san/"/>
      <url>2021/05/31/chong_xue_cao_zuo_xi_tong_san/</url>
      
        <content type="html"><![CDATA[<h2 id="重学操作系统（三）"><a href="#重学操作系统（三）" class="headerlink" title="重学操作系统（三）"></a><center>重学操作系统（三）</center></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前面试遇到了递归转非递归的问题，当时把我难住了。今天就看到了相关的文章，悔不当初，应该早点看。现在就把这个文章总结下，加深记忆。</p><h2 id="贯穿全文的问题：不支持递归的程序语言如何实现递归"><a href="#贯穿全文的问题：不支持递归的程序语言如何实现递归" class="headerlink" title="贯穿全文的问题：不支持递归的程序语言如何实现递归"></a><em><strong>贯穿全文的问题：不支持递归的程序语言如何实现递归</strong></em></h2><h3 id="for循环执行"><a href="#for循环执行" class="headerlink" title="for循环执行"></a>for循环执行</h3><pre><code>int sum = 0;for (int i = 1; i &lt;= 100; i++) {    sum += i;}</code></pre><p>上面代码很简单，就是通过for循环，获得1 - 100相加和。但是如果是计算机指令执行，就比上述代码复杂很多，大体比如：</p><pre><code># var i = 1, s = 0# 对应 Java 代码，我们首先将 1 和 0 存储到两个地址# 这两个地址我们用 $i 和 $s 表示store #1 -&gt; $i // 将数字 1 存入i的地址store #0 -&gt; $s // 将数字 0 存入 s 的地址# 接下来循环要开始了，我们在这里预留一个 loop 标签# loop 是一个自定义标签，它代表指令的相对位置# 后续我们可以用 jump 指令跳转回这个位置实现循环loop: # 循环标签# for ... i &lt;= 100# 接下来我们开始实现循环控制# 我们先首先 i &lt;= 100的比较# 我们先将变量 i 的地址，也就是 $i 导入寄存器 R0load $i -&gt; R0# 然后我们用 cmp 比较指令 R0 和数字 100cmp R0 #100 // 比较 R0 和数字 100# 注意指令不会有返回值，它会进行计算，然后改变机器的状态（也就是寄存器）# 比较后，有几个特殊的寄存器会保存比较结果# 然后我们用 ja（jump above）, 如果比较结果 R0 比 100 大# 那么我们就跳转到 end 标签，实现循环的跳出ja end nop# 如果 R0&lt;=100，那么ja end 没有生效，这时我们处理 s+=i# 首先我们把变量 s 所在地址的数据导入寄存器 R1load $s -&gt; R1# 然后我们把寄存器R0和R1加和，把结果存储寄存器 R2add R0 R1 R2 # 这时，我们把寄存器 R2 的值存入变量 s 所在的地址store R2 -&gt; $s# 刚才我们完成了一次循环# 我们还需要维护变量 i 的自增# 现在 i 的值在 R0 中，我们首先将整数 1 叠加到 R0 上add R0 #1 R0# 再把 R0 的值存入i所在的内存地址store R0 -&gt; $i# 这时我们的循环体已经全部执行完成，我们需要调转回上面 loop 标签所在的位置# 继续循环jump loopnopend:</code></pre><center>代码来源于参考一</center><p>其实上述就可以看作一种汇编语言，我没学过汇编，但是学过C语言，感觉编写逻辑也是和上述类似的。通过上述方式，上面的for循环操作成功转换成指令，然后在编码成二进制，就能存在内存中了。</p><h3 id="条件控制程序"><a href="#条件控制程序" class="headerlink" title="条件控制程序"></a>条件控制程序</h3><p>主要是if-else和switch-case，if-else是自上向下执行，所以如果有1000个case，最坏结果是执行999次。而switch-case是可以通过数学方法，精确定位到相应的case。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的执行，深入到底层，涉及到栈这种数据结构。比如下面这个两数相加的方法：</p><pre><code>int add(int a, int b) {    return a + b;}</code></pre><p>在上述例子中，栈的主要作用是解决两个问题，一是参数如何传递给函数，而是返回值如何传递给调用者。</p><p>因此上述方法执行顺序是：</p><blockquote><p>调用 -&gt; 参数压栈 -&gt; Stack -&gt; 取出参数 -&gt; 函数执行</p></blockquote><p>上述方法返回结果顺序是：</p><blockquote><p>函数执行 -&gt; 写入结果，参数出zhan -&gt; Stack -&gt; 取出结果 -&gt; 调用</p></blockquote><p> 参数入栈叫做压栈，结果取出叫做出栈。栈中每个数据大小一样，所以函数执行中，我们通过参数个数和参数的序号计算参数在栈中的位置。</p><p> 例如执行11 + 15:</p><pre><code>1. 压栈参数112. 压栈153. 返回值压栈（这时候是0）4. 调用函数，结果写入返回值5. 存储函数调用前存储的指针，方便函数结束后，跳转回去6. 函数参数和返回值换位置，清除，这样就从参数先清除，不会出现异常</code></pre><h3 id="递归的执行"><a href="#递归的执行" class="headerlink" title="递归的执行"></a>递归的执行</h3><p>给出一个递归的例子：<br>    int sum(int n) {<br>        if (n == 1) return 1;<br>        return n + sum(n - 1);<br>    }</p><p>递归的时候，每次执行，都会形成一个参数 -&gt; 返回地址 -&gt; 返回值这样的栈结构。比如sum（1000）第一次调用n，第二次调用99。这样的话，栈会非常大。消耗了更多的空间，但是保证一定的独立性。递归需要退出条件，不然就会死循环。因为递归和栈存取数据方式类似，因此栈是实现递归的一种方式。而大部分编程语言，是用栈来实现递归的。</p><h3 id="类型（class）的实现"><a href="#类型（class）的实现" class="headerlink" title="类型（class）的实现"></a>类型（class）的实现</h3><p>总结前面的：</p><ol><li>变量是一个内存地址，只需要分配内存就好（指针）</li><li>循环控制：跳转➕判断</li><li>条件控制：跳转➕判断，switch-case需要一些数学计算</li><li>函数：参数压栈，结果出栈，返回值，返回地址</li></ol><p>那么，class是如何被指令实现的？</p><p>class可以分为两部分，一部分是属性，另一部分是方法。而class有一个特殊的函数叫构造函数，它会为class分配内存。构造函数执行时，扫描class中定义的所有属性和方法。</p><ol><li>遇到属性，为属性分配内存地址</li><li>遇到方法，方法本身存到程序所在内存区域，方法的值设置为方法指令所在的内存地址</li></ol><p>当调用一个class的方法时候，本质是执行了一个函数，和函数调用一致：</p><ol><li>返回值返回地址压栈</li><li>参数压栈</li><li>执行跳转</li></ol><h4 id="this指针的实现"><a href="#this指针的实现" class="headerlink" title="this指针的实现"></a>this指针的实现</h4><blockquote><p>把this作为函数的第一个参数压栈，这样class的函数就能访问class的成员了。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>将程序编译成指令 - 编译器</li><li>图灵完备语言：一个语言的能力和图灵机等价，也就是说，平时编程做的事，指令也能做到，所以计算能力等价。也就是一种编程语言的能力，与图灵机等价，称为图灵完备语言。</li></ol><h4 id="贯穿全文的问题-》不支持递归的程序语言如何实现递归？"><a href="#贯穿全文的问题-》不支持递归的程序语言如何实现递归？" class="headerlink" title="贯穿全文的问题 =》不支持递归的程序语言如何实现递归？"></a>贯穿全文的问题 =》不支持递归的程序语言如何实现递归？</h4><blockquote><ol><li>我们需要一个栈（数组就可以）</li><li>我们需要一个栈指针，或者类似Java这种，用变量</li><li>然后实现压栈出栈等操作</li></ol></blockquote><p>斐波那契求第n项：</p><pre><code>int fib(int n) {if(n == 1 || n == 2) { return n; }    return fib(n-1) + fib(n-2)}</code></pre><p>改写为非递归：</p><pre><code>private static int fib2(int n) {     if (n == 1 || n == 2) {         return n;     }     //初始化数据     int[] stack = new int[n];     int point = n - 3;     stack[n - 1] = 1;     stack[n - 2] = 2;     //数组模拟出栈入栈     while (point &gt;0) {         stack[point] = stack[point + 1] + stack[point + 2];         point--;     }     return stack[0];}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4609">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=4609</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 相关原理 </tag>
            
            <tag> 图灵机 </tag>
            
            <tag> 冯诺伊曼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学操作系统（一）</title>
      <link href="2021/04/02/chong_xue_cao_zuo_xi_tong_yi/"/>
      <url>2021/04/02/chong_xue_cao_zuo_xi_tong_yi/</url>
      
        <content type="html"><![CDATA[<h2 id="重学操作系统（一）"><a href="#重学操作系统（一）" class="headerlink" title="重学操作系统（一）"></a><center>重学操作系统（一）</center></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我准备写一篇文章，记录下我学习操作系统的过程和一些关键知识点。题目是借用了拉钩教育上某个课程的题目[1]，感觉很贴切。之所以想学习操作系统，是因为某个面试问了很多jvm，mysql，redis调优以及操作系统相关的问题（Linux为主），我之前只是知道皮毛，因此惨败。借此补充下欠缺的知识，然后顺手记录下，留给自己看，也能促使自己记得更牢固。</p><p>目前，全文所有知识点均来源于参考一那个教程中，未来会遇到问题，再补充。</p><h3 id="为什么要学习操作系统？"><a href="#为什么要学习操作系统？" class="headerlink" title="为什么要学习操作系统？"></a>为什么要学习操作系统？</h3><ol><li>有很多操作系统相关的高频面试题。</li><li>学好操作系统能更好理解很多问题，即使你编程中遇不到，或者你压根不了解，比如多线程，比如容器等。</li><li>任何研发工具接触到底层，都会涉及到操作系统，比如MySQL的InnoDB，比如Hbase学习会接触到Hadoop（HDFS），Redis会碰到Linux I/O模型，Spring会接触到线程池和调度算法等 。</li></ol><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>因为教程是分模块的，所以后面文章也会分模块。具体一篇包含多少模块，我会按照长度来决定。在最后会有补充模块，未来我遇到相关问题，会添加进去。</p><hr><h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a><center>计算机组成原理</center></h3><h4 id="贯穿模块一的一个问题：可不可以计算一个人的程序写的好不好？"><a href="#贯穿模块一的一个问题：可不可以计算一个人的程序写的好不好？" class="headerlink" title="贯穿模块一的一个问题：可不可以计算一个人的程序写的好不好？"></a><em><strong>贯穿模块一的一个问题：可不可以计算一个人的程序写的好不好？</strong></em></h4><h3 id="芯片和计算能源"><a href="#芯片和计算能源" class="headerlink" title="芯片和计算能源"></a>芯片和计算能源</h3><p>芯片对于计算机的重要性不言而喻，并且广发应用于各种行业，小到点灯微波炉，大到航天器，宇宙飞船，都需要。“计算能量”是参考一中教程提到的一个议题，我自己看了后，有一种茅塞顿开的感觉。和第一，第二次工业革命对比，确实在过去的第三次科技革命，除了革新的产物外，总觉得少了什么，那就应该是，一种新发现的能源。而参考一的作者将计算比作一种能源，现在看来非常合适。而芯片，就是产生这种能量的源头。芯片中的晶体通过震荡产生稳定的脉冲信号，我们发放信号形成方波，最后我们转换信号为我们需要的信号，就形成了时钟信号。这点其实和人类很像，心脏跳动，脉搏跳动，会影响到身体各处的供血，中医可以通过脉搏的跳动，简单判断出你身体的大致情况。而芯片就是这个“心脏”，它也是通过不同“跳动”来传递信号。</p><h3 id="公理化体系和不完备性定理"><a href="#公理化体系和不完备性定理" class="headerlink" title="公理化体系和不完备性定理"></a>公理化体系和不完备性定理</h3><blockquote><p>公理化体系：可以建立起一套完善的公理体系，由少数几个公理推导出所有定理和推论，将万事万物统一到一个体系。</p></blockquote><blockquote><p>不完备性定理（哥德尔不完备性定理）：即使在完善的公理体系中，也可以找到不能证明也不能证伪的命题。</p></blockquote><p>上面两个定理，目前看来应该是第二个是更贴近现实，正如很多科学无法解释的灵异事件，让我们意识到，公理化体系是很难实现的。也让我们看到了，现代科学（计算）是不可能算出所有东西。</p><h3 id="可计算理论"><a href="#可计算理论" class="headerlink" title="可计算理论"></a>可计算理论</h3><blockquote><p>哪些问题可以被计算，哪些问题不能</p></blockquote><p>可计算问题可被图灵机处理，不可计算问题不能被图灵机处理。停机问题：不能用一个程序判断另一个程序是否会停止。停机问题是经典的不可计算问题。</p><h3 id="P问题和NP问题"><a href="#P问题和NP问题" class="headerlink" title="P问题和NP问题"></a>P问题和NP问题</h3><ol><li>P问题：多项式时间问题，我们有能力或者未来有能力解决的问题，例如O(N<sup>1000</sup>)的问题，是P问题，即使现在算不出来，未来也能算出来。</li><li>NP问题：指数形式问题，如：O(2<sup>N</sup>)问题，随着N增大，人类的计算能力增长速度是线性增长的，问题的增长速度会一直和计算能力增长速度持平或者更快。</li><li>因此，不是所有可计算问题，都能被解决，不是多项式时间的可计算问题，都是NP问题。</li><li>部分NP问题能转成P问题，需要通过一些算法，如动态规划等。如斐波那契数列求第N项。</li></ol><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>在参考一中，作者定义人工智能为：一些NP问题，虽然不能解决，但是努力让计算机的解决方案超过人类水平。说实话，这个定义还是很新颖的，也很贴近实际应用。</p><p>最早的人工智能的应用应该就是图灵测试，就是一段人机对话，抽出部分对话交给实验者去判断，如果大部分对话判断为人和人之间的对话，则机器通过了图灵测试。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回到开头的问题，“可不可以计算一个人的程序写的好不好？”，我认为是无法计算的，这是一个不可计算问题。因此在目前来说，我们只能做到设立相应的规则，来规范程序写法，但是并不能提供一个有绝对答案的解法。未来计算机也许会有办法解决，将这个不可计算问题转换成可计算问题。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4604">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4604</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 相关原理 </tag>
            
            <tag> 图灵机 </tag>
            
            <tag> 冯诺伊曼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学操作系统（二）</title>
      <link href="2021/04/02/chong_xue_cao_zuo_xi_tong_er/"/>
      <url>2021/04/02/chong_xue_cao_zuo_xi_tong_er/</url>
      
        <content type="html"><![CDATA[<h2 id="重学操作系统（二）"><a href="#重学操作系统（二）" class="headerlink" title="重学操作系统（二）"></a><center>重学操作系统（二）</center></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一篇文章准备记录下关于32位和64位相关的知识点。32位和64位我们都熟悉，但是大部分人，包括我，都没有真正去研究过，今天借着拉钩教育这个教程，趁机学习并且总结下，留作以后回顾。</p><h4 id="贯穿全文的思考：相比32位，64位的优势是什么？"><a href="#贯穿全文的思考：相比32位，64位的优势是什么？" class="headerlink" title="贯穿全文的思考：相比32位，64位的优势是什么？"></a><em><strong>贯穿全文的思考：相比32位，64位的优势是什么？</strong></em></h4><h3 id="图灵机的两大贡献"><a href="#图灵机的两大贡献" class="headerlink" title="图灵机的两大贡献"></a>图灵机的两大贡献</h3><ol><li>定义了计算机的计算边界，即可计算理论</li><li>定义了计算机的组成，和程序如何执行</li></ol><h3 id="图灵机的构造"><a href="#图灵机的构造" class="headerlink" title="图灵机的构造"></a>图灵机的构造</h3><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/tulingji.png" alt="图灵机的构造" title="图灵机的构造"></p><center>图片来源于参考中的链接</center><p>可以看出，图灵机是很长的白色纸带（模仿内存）和读写头以及一些其它元件（储存元件，控制单元等）组成，这样图灵机就能模仿内存的读写了。</p><p>例如：计算11 + 15</p><blockquote><ol><li>我们先把11，15，+分别写入纸带的三个格子，假定图灵机能识别数字和计算符号。</li><li>图灵机将11和15读入控制单元，控制单元将数字存储到存储单元中。</li><li>遇到加号，读写头将加号传输给控制单元，控制单元识别出加号是预设运算符，因此不放入存储单元，而是传输给运算单元，之后运算单元在存储单元取出11和15，进行运算，将结果存入存储单元，运算单元同时将结果返回给控制单元。</li><li>控制单元将结果返回给读写头，读写头写出结果。</li></ol></blockquote><p>一个问题如果能拆解成图灵机的可执行步骤，那么这个问题就是客可运算的。</p><h3 id="冯诺伊曼模型"><a href="#冯诺伊曼模型" class="headerlink" title="冯诺伊曼模型"></a>冯诺伊曼模型</h3><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/fengnuoyimanmoxing.png" alt="冯诺伊曼模型" title="冯诺伊曼模型"></p><center>图片来源于参考中的链接</center><p>冯诺伊曼模型基本遵循了图灵机的设计，主要分成5个部分：输入，输出，内存，CPU和总线，并且约定用二进制存储和计算，是现代计算机的鼻祖。现代计算机，不管多复杂，都遵循这个模型的设计方式。</p><h4 id="冯诺伊曼模型-内存"><a href="#冯诺伊曼模型-内存" class="headerlink" title="冯诺伊曼模型 - 内存"></a>冯诺伊曼模型 - 内存</h4><p>程序和数据被存储在一个线性排列的存储区域内，存储单元是二进制（bit），最小单位为字节（8位，byte），每个字节对应一个内存地址。内存地址编号由0开始，依次递增（类似数组那种存储方式 0 - 长度 - 1）。内存是随机存取器，读写任何位置，速度一样。</p><h4 id="冯诺伊曼模型-CPU"><a href="#冯诺伊曼模型-CPU" class="headerlink" title="冯诺伊曼模型 - CPU"></a>冯诺伊曼模型 - CPU</h4><p>冯诺伊曼模型中的CPU相对简单一些，负责控制和计算。CPU可以计算多个字节的数值，以应对较大数值计算。</p><blockquote><ol><li>32位：CPU能计算4Byte</li><li>64位：CPU能计算8Byte</li></ol></blockquote><p>为什么这么设计CPU？</p><blockquote><p>一个byte范围是0-255，因此CPU需要支持多个byte一起计算。32位的CPU已经能计算到2<sup>32</sup> - 1（4294967295）。</p></blockquote><ul><li><p>控制单元和逻辑运算单元</p><ul><li>控制单元负责控制CPU工作，逻辑运算单元负责计算。</li></ul></li><li><p>寄存器</p><ul><li>存储将要被计算的数字，寄存器离计算单元和控制单元很近，速度很快。</li><li>通用寄存器：可供用户编程，比如用来存加和指令的两个参数。</li><li>特殊寄存器：程序指针是一个特殊寄存器，存储了CPU要执行的下一条指令所在的地址。</li><li>指令寄存器：下一条指令被内存读入指令寄存器，在指令执行结束前，它都被存在指令寄存器中。</li></ul></li><li><p>总线</p><ul><li>用于CPU和内存等其它设备通信用的</li><li>地址总线：指定CPU将要操作的内存地址。</li><li>数据总线：用来读写内存中的数据。</li><li>CPU读取内存：先通过地址总线指定内存地址，再通过数据总线来传输数据。</li><li>控制总线：用来发送和接收关键信号，比如设备的中断，就绪，复位等信号。</li></ul></li><li><p>输入输出设备</p><ul><li>输入设备：向计算机输入数据。</li><li>输出设备：数据计算完，经过输出设备向外界传递。</li><li>输入输出设备和CPU传递信号，需要用到控制总线。</li></ul></li></ul><h3 id="线路位宽"><a href="#线路位宽" class="headerlink" title="线路位宽"></a>线路位宽</h3><p>数据是通过电压来传递的，低电压为0，高电压为1。如果只有一条线路，每次传一个信号，如果构造1100，就需要传递4次。这种一个bit一个bit发的方式，叫做串行。因此要一次传递多个信号，就需要增加线路。</p><p>例如：</p><blockquote><p>一条地址总线，每次就能操作两个内存地址，0或者1。如果10条总线，可以操作1024个地址，如果希望操作4G内存地址，因此需要32条地址总线。串行可以接受，但是每增加一条总线，速度都会翻倍。</p></blockquote><h3 id="64位和32位的计算"><a href="#64位和32位的计算" class="headerlink" title="64位和32位的计算"></a>64位和32位的计算</h3><p>场景：32位的CPU，加和两个64位的数。</p><blockquote><p>32位的CPU计算大于32位的数，需要制定相应规则，比较麻烦，因此32位CPU最好操作32位的地址和数据总线。</p><p>计算过程：<br>将64位数拆成两个32位数计算，需要类似我们算数学题，先加和低位，后加和高位，然后加上进位。</p><p>而64位CPU可以直接读如64位数，然后进行计算。但是计算小于32位数字，两个CPU性能没区别。</p><p>32位CPU最多有32个寄存器，最多操作4G内存地址。</p></blockquote><h3 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h3><h4 id="CPU执行程序："><a href="#CPU执行程序：" class="headerlink" title="CPU执行程序："></a>CPU执行程序：</h4><pre><code>1. CPU读取PC指针指向的指令，把指令导入指令寄存器    * 步骤一：CPU的控制单元操作地址总线，指定需要访问的内存地址    * 步骤二：CPU通知内存设备住被数据，内存设备通过数据总线把数据传入CPU    * 步骤三：CPU收到内存传来的数据，将数据存入指令寄存器2. CPU分析指令寄存器的指令，确定类型和参数3. 如果是计算类型的指令，交给逻辑运算单元计算，如果是存储指令，交给控制单元执行4. PC指针自增，准备获取下一个指令Tips: 32位系统，指令指针自增4（因为32位是4Byte）More:    1. 指令和数据一般不存在一起    2. 64位CPU如果只有40条总线，也只能操作2的40次方的CPU地址（约 1T）    3. 从PC指针读取指令，到执行，到下一个指令的循环，称为CPU指令周期</code></pre><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><pre><code>1. 指令以16进制保存。2. 构造指令的过程叫指令编码，通常由编译器完成。3. 解析指令的过程，叫作指令解码，由CPU完成。4. CPU解码过程：    I. Fetch(获取): CPU通过PC指针读取对应内存地址的指令    II. Decode: CPU对指令进行解码    III. Execution: 执行指令    IV. Store: CPU将结果存回寄存器或者寄存器存入内存</code></pre><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/zhilingxunhuan.png" alt="CPU解析指令的过程" title="CPU解析指令的过程"></p><center>图片来源于参考中的链接</center><pre><code>上述四个步骤，叫做CPU的指令周期。</code></pre><h4 id="指令的类型"><a href="#指令的类型" class="headerlink" title="指令的类型"></a>指令的类型</h4><pre><code>不同类型的指令，参数个数，每个参数位宽都不一样，参数类型分三种：1. 寄存器； 2. 内存地址；3. 数值（整数或者浮点数）</code></pre><p>指令从功能角度可划分为以下5类：<br>    1. I/O类型指令：如处理和内存间交换数据的指令store/load等，或者数据从一个地址转移到另一个地址的指令mov<br>    2. 计算类型指令：最多只能处理两个寄存器，比如加减乘除，位运算，比较大小等<br>    3. 跳转类型指令：修改PC指针，例如编程中的：if-esle，switch-case，函数调用等<br>    4. 信号类型指令：比如发送中断的指令trap<br>    5. 闲置CPU指令nop：执行后，CPU空转一个周期</p><p>指令可以按照寻址模式区分，例如求和指令，可以分成：<br>    1. 将两个寄存器的值相加的指令add<br>    2. 将一个寄存器和一个整数相加的指令addi</p><p>load指令按寻址模式区分：<br>    1. 直接寻址（la）：直接加载一个内存地址中的数据到寄存器<br>    2. 寄存器寻址（li）：直接将一个数值导入寄存器<br>    3. 间接寻址（lw）：将一个寄存器中的数值作为地址，再加载这个地址中的数据</p><h4 id="指令的执行速度"><a href="#指令的执行速度" class="headerlink" title="指令的执行速度"></a>指令的执行速度</h4><p>CPU是利用脉冲转化为时钟信号驱动的，每一次时钟信号的高低电平的转换，就是一个周期，成为时钟周期。CPU主频，就是时钟信号的频率。比如1GHz的CPU，就是时钟信号的频率是1G。多数指令不能在一个时钟周期内完成。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>回到本文最开始，遗留的贯穿全文的问题，64位比32位的优势有哪些？</p><pre><code>1. CPU方面：    a. 64位CPU能执行更大数字的运算    b. 64位CPU可以寻址更大的内存空间2. 程序方面：    a. 指的是指令是32位还是64位。64位机器兼容32位指令，因为只需要兼容机制。而32位机器执行64位指令很难，因为寄存器存不下64位指令3. 操作系统方面：    a. 64位操作系统安装不到32位机器</code></pre><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><pre><code>CPU中怎么存对数？CPU底层不能存对数，只能用逼近法，计算机按照位数，提前设计允许的误差值，然后用e^x - a不断尝试不同x进行逼近。</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>全文参考于：<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4608">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=478#/detail/pc?id=4608</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 相关原理 </tag>
            
            <tag> 图灵机 </tag>
            
            <tag> 冯诺伊曼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点整理-04</title>
      <link href="2020/05/17/java_zhi_shi_dian_zheng_li_04/"/>
      <url>2020/05/17/java_zhi_shi_dian_zheng_li_04/</url>
      
        <content type="html"><![CDATA[<center> <h1>Java知识点整理-04</h1> </center><center> <h2> <font color="lightgray">Java面向对象-02</font> </h2> </center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天继续写一些关于构造方法的知识点。有时候我们会看到，在创建一个实例的时候，会给实例一个初始值，比如：</p><pre><code>Food food = new Food("Beef");</code></pre><p>这句话如果按照上一个文章的写法是：</p><pre><code>Food food = new Food();food.setRecipe("Beef");</code></pre><p>可见如果能在创建实例的时候就给这个实例相应的内容，会简单很多。而帮我们完成这个目标的函数，就是构造函数。</p><h2 id="Java构造函数"><a href="#Java构造函数" class="headerlink" title="Java构造函数"></a>Java构造函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code>实际上，每次创建一个实例时，是通过构造方法来创建实例，比如上述例子：    class Food {        String recipe:        public Food(String recipe) {            this.recipe = recipe;        }    }从上述例子我们能看出，构造函数的基本形式是：    修饰字段 类名(想要初始化的参数列表) {        // 构造函数内容    }构造函数的名字和类名一样，首字母也是大写的，这点和其它函数不同。构造函数没有返回值和返回类型，只有访问可见性的修饰字段。大部分时间，在简单的项目和代码中我们就直接定义构造函数为public，但是构造函数也可以用其它修饰类型，比如private来修饰的。构造函数的参数列表并没有要求，想要在创建实例的时候初始化的字段，都可以放在参数列表。</code></pre><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><pre><code>但是类似我们上一篇文章中的例子，比如：    class Person {        String name;        int age;        // ...其它一些方法    }我们并没有写任何构造函数，但是还是可以创建上述类的实例。这是因为，如果当我们没有定义构造函数时，Java会帮我们生成一个默认的构造函数，这个构造函数不传入任何参数。因此上述例子实际是这样：    class Person {        String name;        int age;        // 默认构造函数        public Person() {        }        // ...其它一些方法    }当我们自定义构造函数时，Java便不会执行默认构造函数，因此上述Food类的例子，我们无法创建一个不传入任何参数的实例。如果想既可以创建带参数的实例，又可以创建不带参数的实例，便只需要把这些构造函数都定义出来。这涉及到另一个概念 - 函数的重载，在后面我会展开说。没有在构造函数中初始化的参数，引用类型默认值时null，int类型是0，boolean类型是false，double是0.0。当类中有多个构造方法的时候，Java可以通过识别参数个数和类型来判断在创建实例时候，需要调用哪一个构造函数。</code></pre><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>上面我提到了一种概念，叫做函数/方法的重载，具体意思就是如果一个类中需要一系列的作用类似，参数不同的方法，则可以把它们定义成一个名字，例如：</p><pre><code>class Food {    public void addFood(String name, int weight) {        //    }     public void addFood(String Name) {        //    }    public void addFood(String[] names, int[] weights) {        //    }}</code></pre><p>上述例子中，我们重载了addFood方法，重载方法的参数不同，但是通常返回类型是相同的。这样我们在使用某个方法时，更灵活，也不会因为定义过多的不同方法名的函数而显得混乱。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章比较短，因为想继续写后面的内容，但是发现后面想写的内容，比较复杂内容比较多，因为我接下来想讲一下面向对象的一个很重要的特性 - 继承和多态。因此这篇文章就这样结尾吧，下一篇文章，便是Java的重头戏之一，继承和多态。    </p>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java Core </tag>
            
            <tag> Java开发 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点整理-03</title>
      <link href="2020/05/12/java_zhi_shi_dian_zheng_li_03/"/>
      <url>2020/05/12/java_zhi_shi_dian_zheng_li_03/</url>
      
        <content type="html"><![CDATA[<center> <h1>Java知识点整理-03</h1> </center><center> <h2> <font color="lightgray">Java面向对象-01</font> </h2> </center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天这篇文章写一下关于Java面向对象的知识点。Java是一种面向对象语言，英文是Object-Oriented Programming，缩写是OOP。要说面向对象，得先说下面向过程语言。C语言就是一种面向过程语言，面向过程，本质就是一步一步执行代码，完成一个程序。比如你需要操作打印机打印东西，面向过程就是：</p><pre><code>1. 链接打印机2. 打开文档3. 开始打印4. 打印结束</code></pre><p>而如果是面向对象语言呢，每个程序都有一个或者若干对象（实例），完成一段程序，就是对象之间互动。比如上述例子：</p><pre><code>1. 创建电脑实例2. 创建打印机实例3. 电脑和打印机通信4. 电脑调用打印5. 请求转到打印机接口并打印</code></pre><p>其实这么简单的例子，看起来区别不大，甚至面向对象好像还麻烦一点。但是面向对象语言的实现方式，很接近我们的现实生活，因此更容易理解。</p><h2 id="Java面向对象的基础"><a href="#Java面向对象的基础" class="headerlink" title="Java面向对象的基础"></a>Java面向对象的基础</h2><p>要想讲面向对象，应该得先了解Java的类和实例。</p><pre><code>1. 类（class）类是一种对象的模版，它定义了如何创建对象。class在Java中也是一种数据类型。比如下面这个例子：    class Food {        public int weight;        public String taste;    }类的定义方式就是：    class 类名 {        修饰字段 类型字段 名称； //类内的字段的定义方式    }一个类中可以有包含多个字段，字段的定义方式类似上述。其中在我们的例子中，修饰字段用的是public，这个修饰字段是表示字段是否能被外部访问。通常public修饰的话，是可以被任何方式访问，其它方式还有，比如：    protected：允许当前类，子孙类和同一个package下的类访问        default（或者不写任何修饰字段）：当前类和同一个package下可见。        private：仅当前类可见类中字段的类型字段是相应的字段类型，比如可以是基本类型，int，double等，也可以是引用类型，比如String，Person，Food这种类类型。2. 实例/对象（instance）实例是对于类模版的一种实现，一个类可以有很多实例，每个实例可能会包含不同的属性。定义了类仅是定义了一个模版，如果要使用这个类的功能，必须要创建该类的实例。Java中创建类的实例的方法是通过new这个关键字，比如上述Food例子：    Food food = new Food();然后通过food.weight就可以获得实例对应的字段的值了。</code></pre><h2 id="Java面向对象-方法"><a href="#Java面向对象-方法" class="headerlink" title="Java面向对象 - 方法"></a>Java面向对象 - 方法</h2><p>对于面向对象来说，类很重要，而另一个也很重要的内容是方法（method）。方法的用途就是提供一些途径去处理类中字段或者其它用户需求的内容。</p><pre><code>1. 方法有时候直接把字段暴露在外这种做法并不好，因为其他人能随意篡改，破坏了Java的一大特性 - 封装性。因此大多数情况，我们会用private修饰字段，因为private修饰的字段，只能在类内可见。因此在外部是无法调用的。所以我们可以用public修饰相应的操作字段的方法。比如下列代码：    class Person {        private String name;        private int age;        public void setPerson(String name, int age) {            this.name = name;            this.age = age;        }    }上述代码，当我们直接用person实例调用name或者age字段时，会报错，如果想修改字段，需要调用setPerson方法：    Person p = new Person();    p.setPerson("Bob", 12);从上述代码我们能看出，方法的基本定义方式如下：    修饰符 返回类型 方法名(参数列表){        // 方法体        // 返回值    }修饰符基本就是public，private这些，还有static，abstract这些，等后面再说。返回类型可以是Java基本类型，比如int，double，也可以是引用类型，比如Person，String。方法名一般没什么要求，但是尽量有意义，方法名的定义规则是第一个单词首字母小写，后面跟着的单词首字母大写，比如setName。这不是强制规定，但是已经形成了业界最基本的书写习惯。参数列表用来罗列出需要传入方法的参数，比如setName方法，你需要传入你想设置的名称，那么setName方法要写成setName(String name)这种形式，参数要写成“参数类型 参数名”这种形式。特别注意，方法通常在执行完是要有return语句返回结果的，比如：    public int getAge() {        return age;    }返回的数据类型要和方法返回类型对应。有时候我们会看到，方法的返回类型被定义为void，这个关键字的意思是空类型。当遇到void时候，通常不需要写return，如果要写，需要写成“return;”。同变量一样，方法也可以用private，protected，default（或者没有修饰符）等修饰。可见性也是一样的，因此如果一个方法是private的，这个方法只能被类内其它方法调用，通常我们会把一些不想要用户使用的方法，设置成private。2. this变量在上述例子中，我们看到了类似this.name = name;的这种使用。this是用来指向类的当前实例。通常this的最常用用法，就是当方法参数名和类内字段名（变量名）冲突，为了区别，使用“this.变量名 = 参数名”这种方式。因为如果少了this，变量可能被认为是局部变量。3. 可变参数在上述例子中，方法参数我们是用“(String name, int age)”这种方式来表示。但是如果我们传入的参数不定，这种方式就不行了。我们可以用可变参数的方式：    class Person {        String[] names;        public void setNames(String... names) {            this.names = names;        }    }    Person p = new Person();    p.setNames("Bob", "Alice", "Kate");    p.setNames("Happy", "Birthday");    p.setNames("Hello World");上述代码我们能看出，setNames接收的是可变变量，可以把传入的参数打包成一个String类型的数组传入方法。上述代码的最常用写法是：    class Person {        String[] names;        public void setNames(String[] names) {            this.names = names;        }    }    Person p = new Person();    p.setNames(new String[] {"Bob", "Alice", "Kate"});    p.setNames(new String[] {"Happy", "Birthday"});    p.setNames(new String[] {"Hello World"});4. 参数绑定参数绑定指调用一个方法时，传入参数，按位置和方法对应的参数绑定。比如：    class Person {        String name;        public void setName(String name) {            this.name = name;        }    }    Person p = new Person();    p.setName("Tony");    上述代码"Tony"字符串会绑定在setName方法的name参数上。当传入的值是基本数据类型时，传入的是值的复制。因此在外部修改传入值，对方法内参数没影响：    class Person {        private int age;        public void setAge(int age) {            this.age = age;        }        public int getAge() {            return age;        }    }    int age = 15;    Person p = new Person();    p.setAge(age);    System.out.println(p.getAge());    age = 20;    System.out.println(p.getAge());上述代码运行后，打印结果都是15。可以看出，虽然传入的age在外部被改变了，但是也没有影响传入的值。而传入的是引用类型时，外部值改变会影响传入函数的值：    class Person {        private String[] names;        public void setName(String[] names) {            this.names = names;        }        public String[] getNames() {            return names;        }    }    String[] names = {"Andrew", "Bob"};    Person p = new Person();    p.setNames(names);    System.out.println(Arrays.toString(p.getNames()));    names[0] = "Luke";    System.out.println(Arrays.toString(p.getNames()));上述代码的结果是“Andrew, Bob”和“Luke, Bob”。因为当传入参数是引用类型，函数内的局部变量则指向引用类型参数值所在的地址，而不是获得了相应的值。等于传入后，方法局部参数和外部传入的参数指向同一个内存地址，因此外部参数修改了内存地址中的内容后，也会影响到函数内部的参数值。当然，如果传入String类型，会出现和传入一个基本类型一样的结果，就是外部变量改变，内部的变量值不会被影响。这是因为，参数传入方法后，外部变量和函数局部变量都指向同一个字符串，而当外部变量改变时，并不是改变了指向地址的字符串值，而是改变了它自己的指向，因此方法内局部变量仍然指向原来指向的字符串，且字符串值并没有变。</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天写了点关于面向对象的基本概念，同时说了下关于类，实例，变量，参数，方法等面向对象语言很重要的基础部分。本想继续说下关于构造函数。但是感觉文章篇幅不想太长。那就下一篇，先说下构造函数，再说下方法重载，因为重载在构造函数中用途很广。如果篇幅不长，下一篇中还会写Java的核心中的核心 - 继承和多态的知识点。    </p>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java Core </tag>
            
            <tag> Java开发 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点整理-02</title>
      <link href="2020/05/05/java_zhi_shi_dian_zheng_li_02/"/>
      <url>2020/05/05/java_zhi_shi_dian_zheng_li_02/</url>
      
        <content type="html"><![CDATA[<center> <h1>Java知识点整理-02</h1> </center><center> <h2> <font color="lightgray">Java条件和判断语句</font> </h2> </center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天想写一下关于条件和循环语句的一些知识点，Java中的条件语句主要有if相关语句和switch语句。循环语句主要有while相关语句和for循环语句。Java利用这些语句，来实现对程序流程的控制。</p><h2 id="Java条件语句"><a href="#Java条件语句" class="headerlink" title="Java条件语句"></a>Java条件语句</h2><h3 id="1-if条件语句"><a href="#1-if条件语句" class="headerlink" title="1. if条件语句"></a>1. if条件语句</h3><pre><code>1. if语句顾名思义，就是如果满足某个条件，就执行某段程序。基本用法是；    if (条件) {        // 条件满足后执行的代码    }上述中，如果条件的返回结果是true，则继续执行大括号内内容。2. if语句执行块只有一行代码，可以省略大括号：    if (条件)        // 满足条件后的执行代码3. if语句块后，可以跟着else语句，如果if语句块条件判断为true，则执行if语句块内的代码，否则，执行else中代码，比如：    if (条件) {        // 条件=true，执行这里    } else {        // 条件=false，执行这里    }4. if和else之间可以用多个else if来串联，比如下面这个示例：    if (条件1) {        // 条件1=true，执行这里    } else if (条件2){        // 条件2=true，执行这里    } else if (条件3){        // 条件3=true，执行这里    } else {        // 三个条件都不满足，执行这里    }上述例子中的所有条件，可以是表达式，某个变量等，只要最终结果是boolean结果或者可以转成boolean结果，一般都行。5. if语句是从上往下来判断执行的，因此如果上面的条件包含后面语句的条件，则后面的判断块内代码执行不了，比如：        int score = 87    if (score &gt;= 60) {        System.out.println("及格");    } else if (score &gt;= 90){        System.out.println("优秀");    } else if (score &gt;= 75){        System.out.println("良好");    } else {        System.out.println("不及格");    }    上述代码结果是：及格上述可以看出，如果score是89分，我们的本意是想划分为良好，但是由于score &gt;= 60在最上面，只要score大于60，则会执行其代码块内的代码，因此上述代码结果是"及格"，而不是我们想要的良好。因此写代码一定要注意，几个互相有重叠的条件，范围大的条件语句要放在下面。</code></pre><h3 id="2-switch条件语句"><a href="#2-switch条件语句" class="headerlink" title="2. switch条件语句"></a>2. switch条件语句</h3><pre><code>1. 其实switch语句用的相对较少，而且switch语句是可以翻译成if相关语句来表示的。switch语句的最简单的表达方式是：    switch(表达式) {        case 表达式1:            break;        case 表达式2:            break;    }2. switch小括号中的表达式以前只能是数字，现在也可以是字母，字符串之类的了。程序进入switch语句后，直到遇到break才会结束，因此如果类似下方的例子：    int opt = 1;    switch(opt) {        case 1:            System.out.println(opt);        case 2:            System.out.println(opt);            break;    }上述代码我们的本意是打印相对应的输入，比如输入数字1就打印1，输入数字2就打印2。但是由于case 1中没有break，代码会继续执行case 2。因此，如果没有break，代码会继续向下方的case执行，直到遇到break，这种现象叫做case语句的穿透性。3. 如果switch表达式在case中没有对应的选项，那程序会从上到下判断所有case，发现没符合的，就结束了。但是如果我们想要输出一些东西，就需要用到另一个关键字 - default。    int score = 78;    switch(score) {        case 1:            System.out.println(opt);            break;        case 2:            System.out.println(opt);            break;        default:            System.out.println(opt);            break;    }上述代码中，78不符合所有case，因此程序会执行default中的代码，依旧可以打印相应的数字。4. 如果两个case可以使用一种处理方式，那么两个case可以连着写，比如：    int score = 1 // 2;    switch(score) {        case 1:        case 2:            System.out.println("Valid Option");            break;        default:            System.out.println("Invalid Option");            break;    }上述代码无论是输入score = 1还是2，都会得到Valid Option这个结果。5. switch语句如果保证有break，则case语句的顺序就不重要了。但是为了便于阅读，建议还是按照自然顺序去写。6. 以前的switch语句表达式只能是整数，现在可以是字符串和字符。如果是字符串，switch语句表达式和case后的表达式匹配时，比较的是内容。    String food = "cake";    switch(food) {        case "cake":            System.out.println("Option: " + food);            break;        case "bread":            System.out.println("Option: " + food);            break;        default:            System.out.println("Option: " + food);            break;    }上述代码输出的是cake。7. switch也可以接收枚举类型作为表达式。8. Java12之后，switch加入了类似模式匹配的表达方式，这种情况下，可以省略break。比如如下代码：    String food = "cake";    switch(food) {        case "cake" -&gt; System.out.println("Option: " + food);        case "bread" -&gt; System.out.println("Option: " + food);        default -&gt; {            System.out.println("Option: " + food);            System.out.println("Option: " + food);        }    }9. switch语句可以用来给变量赋值，如下方代码：    int opt = -1;    String food = "cake";    switch(food) {        case "cake":            opt = 1;            break;        case "bread":            opt = 2;            break;        default:            opt = 3;            break;    }程序执行结束后，opt被赋值为1。10. 使用switch新语法，不但不需要使用break，还可以直接通过返回值来给参数赋值。    int opt = -1;    String food = "cake";    opt = switch(food) {        case "cake" -&gt; 1        case "bread" -&gt; 2        default -&gt; 3    }上述代码执行结束后，opt的值也是1。这种赋值方式简洁了很多。而且也不会因为忽略break而产生问题。11. 如果需要返回复杂语句执行后的结果，上述方式则不好用了，这时候可以使用yield关键字来返回所需的内容。    int opt = -1;    String food = "apple";    opt = switch(food) {        case "cake" -&gt; 1        case "bread" -&gt; 2        default -&gt; {            int temp = opt * 10 + 1 / 2;            yield temp;        }    }上述代码返回结果是temp计算出来的结果。这样，不管语句多复杂，我们都可以顺利获得想要的返回值。</code></pre><h2 id="Java循环语句"><a href="#Java循环语句" class="headerlink" title="Java循环语句"></a>Java循环语句</h2><h3 id="1-while，do-while循环语句"><a href="#1-while，do-while循环语句" class="headerlink" title="1. while，do while循环语句"></a>1. while，do while循环语句</h3><pre><code>1. 循环语句的用途是非常广泛的，如果需要多次运行同一段程序，则需要用到循环语句。比如下列代码：    int sum = 0;    sum = sum + 1;    sum = sum + 2;    sum = sum + 3;上述代码得到的结果是1+2+3的和。这样写很麻烦，但是用循环，就简单很多了：    int sum = 0;    int num = 1;    while (num &lt;= 3) {        sum = sum + num;        num++;    }上述代码的结果还是1+2+3的和。但是上述用到了while循环，代码就简单很多了。2. 由上述代码我们能看出while循环的基本形式是：    while(条件表达式) {        // 循环语句    }while每次循环开始前，都会判断条件表达式是否成立，只有条件表达式返回true，才会进入循环体。否则就跳出循环，执行后面的代码。由于while循环是先判断，后进入循环体，因此可能一次循环都不执行。while循环条件很多时候是变化的，比如自增或者自减，因此需要特别注意边界问题。3. 所有循环语句，不论是while，for，还是do while，都会存在死循环的问题。死循环的产生原因是，条件永远符合。比如：    int sum = 0;    int num = 1;    while (num &lt;= -1) {        sum = sum + num;        num++;    }上述代码会一直执行下去，直到内存溢出。而且这样无限循环下去，cpu占用会很高，电脑会变卡。其实上述代码到了一定程度仍然会退出，因为当num达到int类型最大值后，num会变为负数，循环还是会退出，因此上述只是模拟一个类似死循环。4. do while其实相对while，用的少很多，do while和while最大的区别在于最少执行次数。while循环体最少执行0次，因为while是先判断后进入循环。而do while循环体最少执行1次，因为do while是先执行循环体，后判断。do while的基本书写形式是：    do {        // 循环体    } 　while (表达式);如果用do while计算1+2+3的和的话，代码是：    int sum = 0;    int num = 1;    do {       sum = sum + num;       num++;    } 　while (num &lt;= 3);其实上述代码看起来和while区别不大，但是比如后面的例子，do while和while执行后会有区别。    int num1 = 1;    int num2 = 1;    while (num1 &lt; 1) {        num1++;    }    do {        num2++;    } while (num2 &lt; 1);上述代码执行结束后，num1的结果还是1，但是num2的结果是2了，因此能看出do while比while多执行了一次。</code></pre><h3 id="2-for循环语句"><a href="#2-for循环语句" class="headerlink" title="2. for循环语句"></a>2. for循环语句</h3><pre><code>1. for循环的使用感觉比while的使用还要广泛，for循环的基本形式是：    for (循环条件初始化; 循环条件判断; 更新循环条件) {        // 执行语句    }循环条件初始化，就是类似之前while循环之前，定义一个计数器，比如int num = 0;通常for使用计数器实现循环，别的其它条件的，比如用一个参数是true或者false，一个数组长度是不是0来判断，则用while比较好。for循环的执行顺序是：循环条件初始化 -&gt; 循环条件判断 -&gt; 循环体内执行语句 -&gt; 更新循环条件。2. for循环写1+2+3的和：    int sum = 0;    for (int i = 1; i &lt;= 3; i++) {        sum = sum + i;    }上述代码我们能看出，如果用计数器实现循环，for循环的代码比while循环的代码更简洁，也不容易出错。比如while循环中，很容易漏掉更新计数器这一步。3. for循环的小括号内分号分开的三个部分不是必须的。省略任何一个，两个或者三个都省略，是可以的。比如下面几个例子：    例1:         int sum = 0;        int i = 1;        for (; i &lt;= 3; i++) {            sum = sum + i;        }    例2:         int sum = 0;        int i = 1;        for (; i &lt;= 3; ) {            sum = sum + i;            i++;        }    例3:         int sum = 0;        int i = 1;        for (;;) {            sum = sum + i;            i++;        }上述几个例子是for循环的一些使用，例3可能会导致死循环，通常不推荐，造成的结果和上面while循环死循环类似，只不过上面while循环可以停下来，for这个真的停不下来。4. for循环是通过使用计数器来实现循环，比如要是获取一个数组的所有元素，for循环写法是：    int[] arr = {1,2,3,4,5};    for (int i = 0; i &lt; arr.length; i++) {        System.out.println(arr[i]);    }上述可见，我们定义一个循环计数器，以数组角标为循环计数器，这种做法是最普遍的。然后判断角标不要越界，每次循环体执行完毕，更新循环计数器。5. 但是如果我们不需要角标，还有更简单直观的写法，就是for each循环的写法：    int[] arr = {1,2,3,4,5};    for (int num : arr) {        System.out.println(num);    }for each 循环写法可以直接获取数组内的元素，for each是基于迭代器来获取元素的。因此只要是能被迭代的数据结构，都能用for each来循环。for each的基本形式是：    for (数据类型 变量名 ：待循环数据结构) {        // 执行代码    }for each循环获取数据结构内元素非常方便，但是由于获取不到角标，因此需要操作角标的操作，则不能用for each。    </code></pre><h3 id="3-break和continue"><a href="#3-break和continue" class="headerlink" title="3. break和continue"></a>3. break和continue</h3><pre><code>1. 接下来说两个循环中最常用的关键字：break和continue。break语句是用来跳出这个循环的，类似switch语句的break。continue顾名思义，跳过这次循环，继续下一次循环。下面代码展示了它们两个的使用场景：    例1:        int[] arr = {1, 2, 3};        for (int i = 0; i &lt; 3; i++) {            if (i == 2) break;            System.out.println(arr[i]);        }        结果是：            1            2上述例子，打印结果没有最后一个数字，因为当角标等于2，程序直接break跳出循环，没有继续执行打印语句。    例2:        int[] arr = {1, 2, 3};        for (int i = 0; i &lt; 3; i++) {            if (i == 1) continue;            System.out.println(arr[i]);        }        结果是：            1            3上述例子，打印结果没有2，因为当角标等于1，程序进入if语句，执行continue，跳过本次循环继续下一次循环，没有继续执行打印语句。2. 多层循环嵌套的话，break总是跳出自己所在的那层循环，continue也是作用于自己所在的那层循环，它们不会直接影响到其它内层或者外层的循环。</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天写了些关于条件语句和循环语句的知识点。都很简单，而且也都很常用。接下来，下一篇，我要开始写一下Java的核心 - 面向对象相关的知识点了。    </p>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java Core </tag>
            
            <tag> Java开发 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点整理-01</title>
      <link href="2020/04/25/java_zhi_shi_dian_zheng_li_01/"/>
      <url>2020/04/25/java_zhi_shi_dian_zheng_li_01/</url>
      
        <content type="html"><![CDATA[<center> <h1>Java知识点整理-01</h1> </center><center> <h2> <font color="lightgray">Java基础部分</font> </h2> </center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>和上一篇笔记，隔了几个月，这几个月疫情持续爆发，我也是纠结在回国还是暂时留在美国中犹豫不决，到了四月，已经无票可买。看起来，滞留美国遥遥无期，好在到了关键时刻，能延长。从三月到四月，一直在为了买票，打包行李焦头烂额。因此没找出时间来继续写东西。今天思考了一上午，终于对于去留下定决心，现在心里的石头落下了，可以安心继续学习了。</p><p>今天想写点和Java相关的，面试需要用的一些知识点，第一呢，是为了我自己未来面试，不用四处查找。第二是复习一下之前的知识点，因为我发现，很多知识点，几周不看，就会忘记。第三就是，如果有机会，能被别人看到我的博客，希望对你有些帮助。</p><h2 id="Java基础知识点"><a href="#Java基础知识点" class="headerlink" title="Java基础知识点"></a>Java基础知识点</h2><h3 id="1-面向对象和面向过程对比"><a href="#1-面向对象和面向过程对比" class="headerlink" title="1. 面向对象和面向过程对比"></a>1. 面向对象和面向过程对比</h3><pre><code>面向过程：性能相对高于面向对象语言，类调用需要实例化，因此消耗资源比较大。性能为重的项目，比如嵌入式开发，单片机等，通常用面向过程类语言开发。当然，类似嵌入式这种，需要用到面向过程开发的第二个原因，是因为面向过程语言通常会将代码直接编译成可执行的二进制机械码。但是面向过程语言的复用性，扩展性和维护性上比面向对象语言要低很多。面向对象： 性能相对于面向过程语言较差，因为大部分面向对象语言（比如Java）都不会将代码直接编译为可执行的二进制机械码。但是面向对象语言，由于有继承，封装等特性，复用性，维护性和可扩展性会比面向过程语言高很多。并且，面向对象语言可以设计出低耦合系统，系统会更灵活，更容易维护，也更不容易出错。</code></pre><h3 id="2-字符型常量和字符串常量的区别"><a href="#2-字符型常量和字符串常量的区别" class="headerlink" title="2. 字符型常量和字符串常量的区别"></a>2. 字符型常量和字符串常量的区别</h3><pre><code>字符型常量：1. 单引号引起的单个字符，如'a', '1', '?'等。2. 字符常量相当于一个整型值，可以参加表达式运算，比如'2'-'0' -&gt; 返回一个整型数值2。3. Java中字符常量占两个字节。4. 可以接受unicode字符，如'大'等。字符串常量：1. 双引号引起的一个或者多个字符，如"abc", "ab2"等。2. 字符串常量指向一个内存地址，这个地址中存放了字符串值。3. 字符串大小是若干字节。4. 是最常用和最基本的引用类型。5. 可以简单的使用 + 来连接两个字符串，比如 "hello " + "world"，得到的结果是"hello world"。6. 多行字符串，在Java13之前，Java本身不支持多行字符串，只能自行拼接，例如：    String s = "first line \n"     + "second line \n"     + "end";但是Java13开始，Java引入了类似Python中的多行字符串，例如：    String s = """                 first line,                second line,                end               """; 7. 字符串是不可变的，因此每次给一个字符串型变量赋值，其实是改变其指针的指向。8. 字符串变量可以指向一个空值null。</code></pre><h3 id="3-Java变量，常量和数据类型"><a href="#3-Java变量，常量和数据类型" class="headerlink" title="3. Java变量，常量和数据类型"></a>3. Java变量，常量和数据类型</h3><pre><code>1. 基本数据类型：    整数类型：byte，short，int，long    浮点数类型：float，double    字符类型：char    布尔类型：boolean    各数据类型数据占用的字节数：    byte：1个字节（8位，8bits）    short，char：2个字节    int，float：4个字节    double，long：8个字节    float型浮点数，通常要加上f后缀表示，如7.89f    long型整数，也可以加上l后缀，如192837437l    boolean类型只有true和false两个值。2. 变量和常量：    double pi = 3.14；    final double PI = 3.14159；    上面两行代码，第一行是Java中变量定义的例子，第二行定义的是常量。很明显，final关键字定义的变量，不能被再次修改，可以视作常量。在Java中，常量通常用大写来表示。3. Var关键字    Var关键字是Java10中新增的，跟Javascript类似，用var定义变量后，Java编译器会自己推断相应的变量的数据类型。var的最大作用是，如果遇到一些很长的变量类型，用var会短很多。</code></pre><h3 id="4-整数运算"><a href="#4-整数运算" class="headerlink" title="4. 整数运算"></a>4. 整数运算</h3><pre><code>1. 整数运算是精准的，如果是除法的话，也只能得到整数部分。比如15/2，如果是整数运算，只能得到7。2. %：求余数运算，比如15%2 = 1。3. 如果除数是0，编译不会报错，但是运行会报错。4. 整数运算是有范围的，如果超出范围，不会报错，会得到奇怪的结果，比如2147483647 + 1 会得到 -2147483648。因为Java只有带符号整型数字，因此最高位是符号位，如果计算超过范围，最高位改变，因此会变成负数。5. 解决上面4中的问题的方法是，将int型改为long型。6. Java中的计算存在简写方式，比如：    int a = 2;    int b = 3;    a += 1; // a = 3    b -= 1; // b = 2    a /= 3; // a = 1;    b *= 2; // b = 4;7. Java中还有自增（++）和自减（--）运算符，比如：    int a = 9;    System.out.println(a++); // 打印 9，a = 10    System.out.println(++a); // 打印 11， a = 11    可以看出，自增（或者自减）运算符在变量前，先执行自增（或者自减），再引用，反之，先引用，后计算。</code></pre><h3 id="5-浮点数运算"><a href="#5-浮点数运算" class="headerlink" title="5. 浮点数运算"></a>5. 浮点数运算</h3><pre><code>1. 浮点数不能做位运算和移位运算。2. 有些浮点数运算不精确（比如0.1，但0.5能精确表示），因此例如下列代码：    double x = 1.0 / 10; // 0.1    double y = 1 - 9.0 / 10; // 0.09999999999999998以上代码，可以看出浮点数计算存在的误差。3. 由于浮点数的误差问题，因此判断两个浮点数相等，通常不直接类似整数那样使用 == 判断，而是：    double r = Math.abs(x - y);    if (r &lt; 0.00001) {}4. 如果是一个整型数和浮点数都参与计算，整型数会被强制提升到浮点型。但是复杂运算中，如果两个整型数先计算，是不会被提升到浮点型。5. 浮点数除以0不会报错，会返回特殊值，比如：    double d1 = 0.0 / 0; // NaN -&gt; Not a Number    double d2 = 1.0 / 0; // Infinity    double d3 = -1.0 / 0; // -Infinity6. 浮点数可以强制转换成整型，比如：int n1 = (int) 12.3; // 12</code></pre><h3 id="6-布尔运算"><a href="#6-布尔运算" class="headerlink" title="6. 布尔运算"></a>6. 布尔运算</h3><pre><code>1. 布尔运算是一种关系运算，包括：    比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!=    与运算： &amp;&amp;    或运算： ||    非运算： !    优先级从高到低：{!} ---&gt; {&gt;，&gt;=，&lt;，&lt;=} ---&gt; {==，!=} ---&gt; {&amp;&amp;} ---&gt; {||}2. 短路运算    运算符左边的布尔运算表达式能提前确定结果，则不需要运算右边的部分。例如：        false &amp;&amp; (1 / 0 &gt; 3)，    前面是false，则返回false，不会尝试计算后面的表达式。因此不报错。另一个例子：        false &amp; (1 / 0 &gt; 3)，        这个则会报错，因为不论前面的表达式结果如何，都会向后计算。    || 运算符也是短路运算符。3. 三元运算符    exp? result1:result2表达式结果返回true，则返回result1，否则返回result2。例如：    int a = 5 &gt; 3? 5 : 3; // a = 5    int b = 5 &lt; 3? 5 : 3; // b = 3</code></pre><h3 id="7-数组类型"><a href="#7-数组类型" class="headerlink" title="7. 数组类型"></a>7. 数组类型</h3><pre><code>数组类型是Java的基础类型之一，定义方式是"类型[]"。例如 int[]。可以在中括号中加数字来决定数组长度，比如int[5]。数组的特点：    1. 数组创建后，其内元素都有默认值。整型默认都是0，浮点型是0.0，布尔型是false。    2. 数组创建后大小不可变。    3. 访问数组元素要使用索引，索引从0开始。    4. 可以快速定义数组内元素，例如：        int[] scores = new int[] {98, 86, 78, 99};                或者        int[] scores = {98, 86, 78, 99};    5. 数组变量也是引用型的变量，它指向一个地址，所以给它赋值，就是改变其指向的地址，并不是真的把相应存储空间中的数组改变了。    6. 对于数组元素类型是引用类型的数组，每个存储空间内存储的是相应元素的地址，比如：        string[] animals = {"dog", "cat", "fish"};    而在数组中并没有直接存储这三个字符串，而是存储了它们相应的地址，如果改变其中某项，如：        animals[1] = bird;        并不是把第二个值改变，而是第二个角标指向从字符串"cat"变为"bird"。        7. 数组可以是多维数组，比如二维数组，例如：        int[][] arr = {            {1,2,3},            {4,5,6},            {7,8,9}        };        获得多维数组的元素的方法是按照角标获取的，二维数组第一个角标代表行数，第二个角标代表列数，比如arr[1][2]，代表获取第二行第三列的元素，即6。通常最多用到三维数组，再更多维，用起来会很麻烦。</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本来想写面试重点的，但是强迫症一不小心写成知识点总结了。那就按步就班继续写吧，今天总结了下Java的一些基础类型，运算，基础数据类型。下一篇应该会写关于条件语句，循环语句，以及数组的更深入的知识点。今天貌似没有什么references，都是基础的，也都是我自己写的，如果有错请指正。    </p>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java Core </tag>
            
            <tag> Java开发 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6的一些知识点整理5</title>
      <link href="2020/02/26/es6_de_yi_xie_zhi_shi_dian_zheng_li_5_md/"/>
      <url>2020/02/26/es6_de_yi_xie_zhi_shi_dian_zheng_li_5_md/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理5</h1> </center><center> <h2> <font color="lightgray">基础部分</font> </h2> </center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天准备说下ES6的新增的功能 - 箭头函数。其实箭头函数在很多其它语言中已经存在了，比如Java。箭头函数是匿名的，而且箭头函数的存在，省却了很多常用的操作。简化了代码，但是在说箭头函数之前，我准备先说下function命名的函数。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>普通函数自然是在ES5版本就已经存在了，相比于箭头函数，普通函数的兼容性自然好很多，下面是普通函数的定义：</p><pre><code>function func() {    console.log("func");}let func2 = function() {    console.log("func2");}func();func2();</code></pre><p>结果是；</p><pre><code>funcfunc2</code></pre><p>显而易见，函数是有两种定义方式的，一种是常规的方式，function关键字后跟着函数名，之后是参数列表，然后是是函数体。第二种是表达式方式，就是函数名在等号左边，函数定义在等号右边。普通函数会绑定this，arguments等关键字，比如下方的例子：</p><pre><code>function a(a) {     console.log("this: ", this, "\n arguments: ", arguments);}a(1,2,3,4);</code></pre><p>结果是：</p><pre><code>this:  Window&nbsp;{parent: Window, opener: null, top: Window, length: 0, frames: Window,&nbsp;…} arguments:  Arguments(4)&nbsp;[1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ]</code></pre><p>普通函数的this指向的是调用他的对象，如上述代码，是直接写在script标签内的，是全局调用的，因此调用他的时候，this对应的是window。当然这是非严格模式下的，如果是定义为严格模式，也就是在代码前加入”use strict”，这个this会指向undefined。下面例子能让我们理解更清晰：</p><pre><code>let obj = {    name: "name1",    func: function() {        console.log(this.name);    }}obj.func();</code></pre><p>结果是：</p><pre><code>name1</code></pre><p>显而易见了，func函数是obj调用的。总之只要记住，普通函数的this指向其调用对象，不管他是函数，对象还是默认的window，就足够了。接着说下arguments，从之前的代码，我们能看到，arguments是普通函数绑定的关键字，类似于this，你不需要自己定义。arguments对应的是传入的所有参数。当然，普通函数还绑定super，指向其父类，这涉及到面向对象的知识，之后我会写专题。至于为什么有的时候普通函数的this并不好用呢，下面的例子可以说明：</p><pre><code>function Person() {    this.a = 20;    setInterval(function setA() {        this.a++;    }, 1000);    console.log(this.a);}let p =new Person();</code></pre><p>结果是：</p><pre><code>20</code></pre><p>根据结果能看出来，Person构造函数的内部有个异步函数，1秒后a+1，但是通过打印结果能看出，这个函数并没有作用于Person这个构造函数中的a变量。因此如果这种情况想要改变Person中的a变量，只能引入一个变量指向Person中的this，如下：</p><pre><code>function Person() {    this.a = 20;    let that = this;    setInterval(function setA() {        that.a++;        console.log(that.a);    }, 1000);    }let p =new Person();</code></pre><p>上述代码中，我们引入了that指向Person函数的this，这样setA函数就能利用that来访问Person函数中的a了。但是这种写法比较麻烦，而且容易出错。箭头函数的一些特性，就是为了简化普通函数的this的使用，以及相关面向对象的使用，使函数看起来不那么像面向对象语言的函数用法。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>顾名思义，就是用箭头表示的函数，它比普通函数更简洁，它没有绑定this，arguments和super。由于它的特性，它在面向对象编程中，不能用于定义构造函数。</p><p>以下是箭头函数的表达方式[1]：</p><pre><code>(param1, param2, …, paramN) =&gt; { statements } (param1, param2, …, paramN) =&gt; expression =&gt; 当只需要返回时，可以省略大括号//相当于：(param1, param2, …, paramN) =&gt;{ return expression; }// 当只有一个参数时，圆括号是可选的：(singleParam) =&gt; { statements }singleParam =&gt; { statements }// 没有参数的函数应该写成一对圆括号。() =&gt; { statements }</code></pre><p><br>当然它还有很多高级用法：</p><pre><code>let test = params =&gt; {    return {foo: "bar"}};//加括号的函数体返回对象字面量表达式[1]let test2 = params =&gt; ({foo: "bar"}); ===》上面的简写版console.log(test(1)); //{foo: "bar"}console.log(test(2)); //{foo: "bar"}</code></pre><p>对于参数方面，虽然箭头函数相对于普通函数没有arguments，但是箭头函数支持剩余参数和参数默认值，如下：</p><pre><code>let a = (item1, item2, ...items) =&gt; {    console.log(item1, item2, items);}a(1, "a", 1, 2, "as", "c"); //打印结果：1 "a" (4)&nbsp;[1, 2, "as", "c"]let b = (item1, item2 = 2) =&gt; {    console.log(item1, item2);}b(1); //打印结果：1 2b(1, 1); // 打印结果：1 1</code></pre><p>首先通过第一个函数a能看出，最后的items通过展开运算符（…）接收了除了1和”a”之外的剩下的所有参数。而b函数则向我们展示了参数默认值的用法，b函数接收两个参数，item1和item2，item2有默认值2，第一次调用它，只传入了一个参数，则item1得到传入值1，item2则保持默认值2，第二次调用，传入两个1，则item2就会被赋予新值，不再保留默认值。但是注意，带默认值的参数，要放在参数列表的最后面。</p><p>接着可以看下下面代码：</p><pre><code>let obj1 = {    name: "name",    func: () =&gt; {        console.log("obj1:",this);    }}let obj2 = {    name: "name",    func: function() {        console.log("obj2:",this);    }}obj1.func();obj2.func();</code></pre><p>运行结果是：</p><pre><code>obj1: Window&nbsp;{parent: Window, opener: null, top: Window, length: 0, frames: Window,&nbsp;…}bj2: {name: "name", func: ƒ}</code></pre><p>显而易见，obj1内实现箭头函数，this指向Window，而普通函数的this指向了obj2这个对象。所以，箭头函数的优势如下：</p><pre><code>function outer() {    this.i = 2;    function inner() {        console.log("this:",this,"i:",this.i);    }    inner();}var outer = new outer();function outer2() {    this.i = 2;    let inner = () =&gt; {        console.log("this:",this,"i:",this.i);    }    inner();}</code></pre><p>   var outer2 = new outer2();</p><p>结果是：</p><pre><code>this: Window&nbsp;{parent: Window, opener: null, top: Window, length: 0, frames: Window,&nbsp;…} i: undefinedthis: outer2&nbsp;{i: 2} i: 2</code></pre><p>显而易见，同样是外部函数作为构造函数，调用了名为inner的内部函数，但是this的指向结果却不同，如果内部函数是普通函数，则this指向全局，也就是Window，所以，第一个this指向Window。而箭头函数没有this，它的this继承自上一层，上一层是outer2的实例，this指向outer2，因此箭头函数的this也指向outer2。因此第一个i的值是undefined，第二个是获取到outer2中的i的值，也就是2.</p><p>如果内部函数为普通函数，也需要得到外部函数的变量，那么可以用下方代码实现：</p><pre><code>function outer() {    this.i = 2;    this.inner = function () {        console.log("this:",this,"i:",this.i);    }    this.inner();}var outer = new outer();</code></pre><p>或者：</p><pre><code>function outer() {    this.i = 2;    let that = this;    var inner = function () {        console.log("this:",that,"i:",that.i);    }    inner();}var outer = new outer();</code></pre><p>结果都是：</p><pre><code>this: outer&nbsp;{i: 2} i: 2</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>箭头函数的基本用法和理解差不多就这么多了，总之，箭头函数没有this，所以对象相关的一切用法，比如new，prototype等，箭头函数都没有。在某些场合，箭头函数确实简化了书写，或者由于箭头函数this继承自上层，因此在某些情况箭头函数用起来更方便，但是只要用到和对象相关的方法或者关键字等，均不能用箭头函数。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6的一些知识点整理4</title>
      <link href="2020/02/02/es6_de_yi_xie_zhi_shi_dian_zheng_li_4/"/>
      <url>2020/02/02/es6_de_yi_xie_zhi_shi_dian_zheng_li_4/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理 - 4</h1> </center><center> <h2> <font color="lightgray">基础部分</font> </h2> </center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介绍了很多关于ES6的新增功能，比如let和const，块状作用域，解构赋值，展开运算符，异步同步等。今天想说一下set和map这两个数据结构。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>先说一下set，Javascript的set类似于其它语言的set，其最大作用就是可以去重，MDN对set的描述是：</p><pre><code>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。[1]</code></pre><p>下面是一个set的例子：</p><pre><code>    let arr = [1,2,3,3,1,2,4];    let set = new Set(arr);    console.log(set);</code></pre><p>运行结果是：</p><pre><code>Set(4)&nbsp;{1, 2, 3, 4}</code></pre><p>通过上述代码，我们能很快很方便的把数组转换成set，数组中的重复的值都被去除掉了。</p><h3 id="Set的常用方法-add-delete-has-clear，forEach"><a href="#Set的常用方法-add-delete-has-clear，forEach" class="headerlink" title="Set的常用方法 - add, delete, has, clear，forEach"></a><strong>Set的常用方法 - add, delete, has, clear，forEach</strong></h3><h3 id="1-add方法"><a href="#1-add方法" class="headerlink" title="1. add方法"></a>1. add方法</h3><p>顾名思义，add方法是向set中添加值的方法。如下方的代码：</p><pre><code>    let arr = [1,2,3,3,1,2,4];    let set = new Set(arr);    console.log(set);    set.add('a');    set.add(1);    set.add(1.1);    console.log(...set);</code></pre><p>结果是：</p><pre><code>    1 2 3 4 "a" 1.1</code></pre><p>通过上方代码，我们分别添加了字符串a，数字1和数字1.1，从结果能看出，添加的值是逐个加入到set后面的，并且由于数字1存在，因此不会被重复添加进去。而且很容易看出，set不是一个固定数据类型的数据结构。至于返回值，add方法的返回值是set本身。</p><h3 id="2-delete方法"><a href="#2-delete方法" class="headerlink" title="2. delete方法"></a>2. delete方法</h3><p>接下来看一下delete方法，这个方法可以帮助我们删除掉set内的指定值。如果要删除的值存在，则删除，如果不存在，则不操作，比如如下代码：</p><pre><code>    let arr = [1,2,3,3,1,2,4, "a", 2.2];    let set = new Set(arr);    console.log(...set);    let res1 = set.delete(1);    console.log(...set);    let res2 =  set.delete(1.1);    console.log(...set);    set.delete("a");    console.log(...set);    console.log(res1, res2);</code></pre><p>结果是：</p><pre><code>1 2 3 4 "a" 2.22 3 4 "a" 2.22 3 4 "a" 2.22 3 4 2.2true false</code></pre><p>从结果的打印，能很容易的看出，当删除1时候，删除成功，之后删除1.1，由于1.1不存在，因此没有操作，最后删除字符串a，删除成功。而且从打印的返回值res1和res2我们能看出，如果删除成功，返回值是true，否则是false。这个返回值，有时候会帮助我们用于判断，决定接下来的操作。</p><h3 id="3-has方法"><a href="#3-has方法" class="headerlink" title="3. has方法"></a>3. has方法</h3><p>has方法很明显，用来判断set中是否存在某个值，MDN对其的描述是：</p><pre><code>has() 方法返回一个布尔值来指示对应的值value是否存在Set对象中。[2]</code></pre><p>接下来一个例子：</p><pre><code>    let arr = [1,2,3,3,1,2,4, "a", 2.2];    let set = new Set(arr);    console.log(...set);    console.log(set.has(1));    console.log(set.has("a"));    console.log(set.has(999));</code></pre><p>结果是：</p><pre><code>1 2 3 4 "a" 2.2truetruefalse</code></pre><p>通过结果，我们能看出，set中包含数字1，2，3，4，字符串a以及浮点数2.2，当我们判断是否存在1和”a”时，由于存在，返回true，当判断999时，因为不存在，则返回false。</p><h3 id="4-clear方法"><a href="#4-clear方法" class="headerlink" title="4. clear方法"></a>4. clear方法</h3><p>接着看下clear方法，这个方法就没什么可说了，就是很简单的清空set。这个方法返回值是undefined。而且不管set是不是空的，都不报错。一个例子如下：</p><pre><code>    let arr = [1,2,3,3,1,2,4, "a", 2.2];    let set = new Set(arr);    console.log(...set);    set.clear();    console.log(set);    set.clear();    console.log(set);</code></pre><p>结果是：</p><pre><code>1 2 3 4 "a" 2.2Set(0)&nbsp;{}Set(0)&nbsp;{}</code></pre><p>显而易见，set被清空，而且重复调用也不会出错。</p><h3 id="5-forEach方法"><a href="#5-forEach方法" class="headerlink" title="5. forEach方法"></a>5. forEach方法</h3><p>forEach方法是很多数据结构都有的方法，用来迭代数据结构中的所有项。MDN描述如下：</p><pre><code>forEach 方法会根据集合中元素的插入顺序，依次执行提供的回调函数。[3]</code></pre><p>从描述中能看出，forEach方法迭代的值和索引，是通过回调函数来使用的，代码如下：</p><pre><code>    let arr = [1,2,3,3,1,2,4, "a", 2.2];    let set = new Set(arr);    set.forEach((val, key, set) =&gt; {        console.log(val,":",key, ":", set);    })</code></pre><p>结果如下：</p><pre><code>1 ":" 1 ":" Set(6)&nbsp;{1, 2, 3, 4, "a",&nbsp;…}2 ":" 2 ":" Set(6)&nbsp;{1, 2, 3, 4, "a",&nbsp;…}3 ":" 3 ":" Set(6)&nbsp;{1, 2, 3, 4, "a",&nbsp;…}4 ":" 4 ":" Set(6)&nbsp;{1, 2, 3, 4, "a",&nbsp;…}a : a : Set(6)&nbsp;{1, 2, 3, 4, "a",&nbsp;…}2.2 ":" 2.2 ":" Set(6)&nbsp;{1, 2, 3, 4, "a",&nbsp;…}</code></pre><p>set的forEach函数第一个参数也是一个回调函数，类似于其他数据结构，但是set的forEach和数组有些不同，由于set没有索引，因此，回调函数的第一个value值和第二个key值都是当前操作项的值。与此同时，他还能接收第三个参数，第三个参数是这个值来源于的哪个数组。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>说完了set，那就不能不说map了，本来想分两篇文章写，但是想了想，还是写了吧。先看下Map在MDN中的描述：</p><pre><code>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。[4]</code></pre><p>下面代码，是map的简单使用：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);    let map2 = new Map([1, 'one'], [2, 'two'], [3, 'three']);    console.log(map2);</code></pre><p>结果是：</p><pre><code>Map(3)&nbsp;{1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}Uncaught TypeError: Iterator value 1 is not an entry objectat new Map (&lt;anonymous&gt;)at demo2.html:110</code></pre><p>从结果我们能看出，创建map不能用下面创建map2的方式，会报错，通过错误提示，我们能看出，创建map时候，传入的必须是一个可迭代的数据结构， 比如数组。接下来看看map的几个常用方法。上述代码中，key是数字1，2，3 等，value是各个key对应的英文单词。</p><h3 id="Map的常用方法-set-get-keys-values-delete-has-clear，forEach"><a href="#Map的常用方法-set-get-keys-values-delete-has-clear，forEach" class="headerlink" title="Map的常用方法 - set, get, keys, values, delete, has, clear，forEach"></a><strong>Map的常用方法 - set, get, keys, values, delete, has, clear，forEach</strong></h3><h3 id="1-set和get方法"><a href="#1-set和get方法" class="headerlink" title="1. set和get方法"></a>1. set和get方法</h3><p>先说下set和get方法，这两个方法很好理解，就是插入新的key-value对，和通过相应的key得到相应的value。下面看一下相应代码：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);    let setAns = map.set(4, "four");    console.log("map: ", map);    console.log("setAns: ", setAns);    let val = map.get(2);    console.log("getVal: ", val);        map.set(1, "oneoneone");    console.log("map: ", map);    console.log(map.get(333));</code></pre><p>结果是：</p><pre><code>Map(3)&nbsp;{1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}map:  Map(4)&nbsp;{1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three", 4 =&gt; "four"}setAns:  Map(4)&nbsp;{1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three", 4 =&gt; "four"}getVal:  twomap:  Map(4)&nbsp;{1 =&gt; "oneoneone", 2 =&gt; "two", 3 =&gt; "three", 4 =&gt; "four"}undefined</code></pre><p>通过上面结果我们能看出，set方法的返回值是map本身，get方法的返回值是获取到的value值，如果没有对应的key，则返回undefined。同时我们能轻松的看出插入和获取的操作，如果插入时，key值不存在，则插入key-value对。如果存在，则更新key对应的value值为新插入的值。</p><h3 id="2-keys和values方法"><a href="#2-keys和values方法" class="headerlink" title="2. keys和values方法"></a>2. keys和values方法</h3><p>通过keys和values方法，我们分别能得到相应的可迭代对象作为返回值，对象中分别按插入顺序存入了所有key值和value值。下面是keys和values的简单用法：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);        let keys = map.keys();    console.log("keys: ", keys);    let values = map.values();    console.log("values: ", values);</code></pre><p>结果是：</p><pre><code>Map(3)&nbsp;{1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}keys:  MapIterator&nbsp;{1, 2, 3}values:  MapIterator&nbsp;{"one", "two", "three"}</code></pre><p>通过结果我们能看出，keys和values方法的返回值都是MapIterator对象，我们能使用Iterator对象的相应方法获取相应的值。</p><h3 id="3-delete方法"><a href="#3-delete方法" class="headerlink" title="3. delete方法"></a>3. delete方法</h3><p>map的delete方法类似set中的delete方法，删除对应key值的value，删除成功返回true，失败返回false。简单用法如下：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);        let ans1 = map.delete(1);    console.log("map: ", map);    console.log("return answer after delete: ", ans1);    let ans2 = map.delete(1);    console.log("map: ", map);    console.log("return answer after delete: ", ans2);</code></pre><p>打印结果是：</p><pre><code>Map(3)&nbsp;{1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}map:  Map(2)&nbsp;{2 =&gt; "two", 3 =&gt; "three"}return answer after delete:  truemap:  Map(2)&nbsp;{2 =&gt; "two", 3 =&gt; "three"}return answer after delete:  false</code></pre><p>从结果显而易见，第一次调用delete，传入参数1，则成功删除key值1对应的值“one”，并且我们能看出，由于删除成功，返回值是true。而第二次再次删除数字1对应的值时，由于之前删除过，map中已经不存在key为1的项，因此删除失败，map不变，返回值为false。</p><h3 id="4-has方法"><a href="#4-has方法" class="headerlink" title="4. has方法"></a>4. has方法</h3><p>has方法也很简单，通过传入的key值，判断是否存在相应的键值对，如果存在则返回true，否则返回false。下面是简单用法：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);        console.log(map.has(1));    console.log(map.has("one"));</code></pre><p>打印结果为：</p><pre><code>Map(3)&nbsp;{1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}truefalse</code></pre><p>从结果能很快看出，当我们传入数字1时，由于map中存在这个key值，因此返回true，相反的，map中不存在“one”，因此第二个has返回的结果时false。</p><h3 id="5-clear方法"><a href="#5-clear方法" class="headerlink" title="5. clear方法"></a>5. clear方法</h3><p>clear方法就更简单了，就是清空map用的。clear方法的返回值是undefined。代码如下：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);        map.clear();    console.log(map);</code></pre><p>结果如下：</p><pre><code>Map(3)&nbsp;{1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}Map(0)&nbsp;{}</code></pre><p>结果显而易见，就不赘述了。</p><h3 id="6-forEach方法"><a href="#6-forEach方法" class="headerlink" title="6. forEach方法"></a>6. forEach方法</h3><p>map的forEach方法和set的略有不同，同样是传入一个回调函数作为参数，不同的是，回调函数的第一个和第二个参数，set由于没有索引，因此两个参数都是相应的值，但是map不同，map的forEach方法中的回调函数的第一个参数是键值对的value值，第二个是key值，下面的例子很清楚：</p><pre><code>    let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);    console.log(map);        map.forEach((val, key) =&gt; {        console.log(key,":",val);    });</code></pre><p>结果是：</p><pre><code>Map(3)&nbsp;{1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three"}1 ":" "one"2 ":" "two"3 ":" "three"</code></pre><p>从结果能很容易看出，map的回调函数也有第三个参数，和set类似，返回这个map，在此不再多说了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天说了两个数据解构，set和map，这两个数据结构并不罕见，很多编程语言中都有，而且在javaScript中的用法和在其它语言中的用法也很类似。可以简单便捷的完成很多其它数据解构不容易完成的任务。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set</a></p><p>[2] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/has">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/has</a></p><p>[3] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach</a></p><p>[4] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6的一些知识点整理3</title>
      <link href="2020/02/02/es6_de_yi_xie_zhi_shi_dian_zheng_li_3/"/>
      <url>2020/02/02/es6_de_yi_xie_zhi_shi_dian_zheng_li_3/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理 - 3</h1> </center><center> <h2> <font color="lightgray">基础部分</font> </h2> </center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来想写一系列的ES6基础的博文，之后再总结一些ES6的高级功能，比如异步同步之类的，但是写完第一个文章后，忘记总结其它基础部分，就直接写了异步和同步。因此这篇文章开始，会继续总结ES6的新增功能和基础知识。应该会写几篇，之前那篇异步同步的文章感觉太长了，以后尽量控制篇幅。</p><h2 id="ES6-块级作用域"><a href="#ES6-块级作用域" class="headerlink" title="ES6 - 块级作用域"></a>ES6 - 块级作用域</h2><p>正如之前说的，ES6中新增的关键字 - let和const的作用范围是块级作用域。下面有个简单的例子用来对比let和var来说明块级作用域：</p><pre><code>    let b;    if (true) {        let a = 1;        b = 2;        var c = 3;        console.log("inside a: " + a);        console.log("inside c: " + c);    }        console.log("outside c: " + c);    console.log("outside a: " + a);    console.log("b: " + b);</code></pre><p>结果是：</p><pre><code>inside a: 1inside c: 3outside c: 3Uncaught ReferenceError: a is not defined</code></pre><p>结合代码和结果，显而易见，var定义的变量c，虽然被定义在if这个块内，但是能被外面用到，而let定义的变量a则不能。接下来再看个复杂的例子：</p><pre><code>    for(let i = 0; i &lt; 5; i++) {        setTimeout(function() {            console.log("i: " + i);        }, 1000);    }        let j;    for(j = 0; j &lt; 5; j++) {        setTimeout(function() {            console.log("j: " + j);        }, 2000);    }</code></pre><p>结果是：</p><pre><code>demo2.html:26 i: 0demo2.html:26 i: 1demo2.html:26 i: 2demo2.html:26 i: 3demo2.html:26 i: 45 demo2.html:33 j: 5</code></pre><p>我们可以看到，第一个for循环，i这个变量是在for循环块内定义的，由于let是块状作用域关键字，因此在这个for块中，i就好像一个实体，每次 + 1，都会产生一个实体。</p><p>第二个for循环，j是在for块外定义的，传入for块内，就像是传入了一个参数，并不作为一个实体在for循环内，因此每次 j + 1，都是修改外面变量指向的内存，并不会创建新的变量。</p><p>同样的代码，改成var的话，比如下面的代码：</p><pre><code>    for(var i = 0; i &lt; 5; i++) {        setTimeout(function() {            console.log("i: " + i);        }, 1000);    }        var j;    for(j = 0; j &lt; 5; j++) {        setTimeout(function() {            console.log("j: " + j);        }, 2000);    }</code></pre><p>结果是：</p><pre><code>5 i: 55 j: 5</code></pre><p>显而易见，i和j均打印了五次，因为var是全局作用域，所以在不在for循环内创建，都会只创建一个，因为是异步操作（上面也是）因此最后传入相应变量的值都是最后一个值，因此都是5。</p><p>以上是对块级作用域的一些见解和使用。如果有不恰当的地方，希望能指正，谢谢了。</p><h2 id="ES6-解构赋值"><a href="#ES6-解构赋值" class="headerlink" title="ES6 - 解构赋值"></a>ES6 - 解构赋值</h2><h3 id="解构赋值-对象"><a href="#解构赋值-对象" class="headerlink" title="解构赋值 - 对象"></a><strong>解构赋值 - 对象</strong></h3><p>接下来说一下ES6的新功能，就是解构赋值，这种功能大大的简化了对象或者数组的取值操作。比如下面代码：</p><pre><code>    let person = {        name: "personName",        age: 12,        weight: 55.5    }    let {name,age} = person;    console.log(name, " : ", age);    let {height} = person;    console.log(height);</code></pre><p>结果是：</p><pre><code>personName  :  12undefined</code></pre><p>上面是解构赋值的最简单用法，很容易获得对象内的相应的参数的值。但是有一点需要注意的是，解构的变量名必须和对象内的参数key值对应。</p><h3 id="解构赋值-数组"><a href="#解构赋值-数组" class="headerlink" title="解构赋值 - 数组"></a><strong>解构赋值 - 数组</strong></h3><p>同样的，可以用类似的方法解构数组，比如：</p><pre><code>    let arr = [1,2,3];    let [a,b] = arr;    console.log("a:", a,"b:",b);    let [d,c] = arr;    console.log("c:", c,"d:",d);</code></pre><p>结果是：</p><pre><code>a: 1 b: 2c: 2 d: 1</code></pre><p>通过结果能看出，解构数组，是通过值索引对应的，也就是第一个变量就是获得索引为0的值，以此类推。</p><h3 id="解构赋值-字符串"><a href="#解构赋值-字符串" class="headerlink" title="解构赋值 - 字符串"></a><strong>解构赋值 - 字符串</strong></h3><p>除了对象和数组，字符串也能解构赋值。如下方代码：</p><pre><code>    let str = "ABCD";    let [a,b] = str;    console.log(a,b);</code></pre><p>结果是：</p><pre><code>A B</code></pre><p>与数组差不多，字符串在解构时，也是会类似数组那样，按照索引获得。同样的，按照索引获取（数组和字符串等），不能用大括号来解构，但是解构对象，是要用大括号解构的。</p><h2 id="ES6-展开运算符"><a href="#ES6-展开运算符" class="headerlink" title="ES6 - 展开运算符"></a>ES6 - 展开运算符</h2><h3 id="展开运算符-数组"><a href="#展开运算符-数组" class="headerlink" title="展开运算符 - 数组"></a><strong>展开运算符 - 数组</strong></h3><p>接下来打算说下展开运算符（…）展开运算符类似解构赋值，可以用于数组和对象等，简化了对数组或对象内的各项的获取步骤。下面是展开运算符的简单使用：</p><pre><code>    let arr = [1,2,3];    console.log(arr);    console.log(...arr);</code></pre><p>结果是：</p><pre><code>(3)&nbsp;[1, 2, 3]1 2 3</code></pre><p>很明显，直接打印arr，则打印的是数组，可以展开查看各项，而使用展开运算符（三个点）则能获取到每一项，而不用像以前一样，要用循环或者其它方法。可见展开运算符有多方便。下面是展开运算符在数组的一些用法：</p><pre><code>    let arr = [1,2,3,4];    let arr2 = ["a", ...arr,"b"];    console.log(arr2);</code></pre><p>结果是：</p><pre><code>(6)&nbsp;["a", 1, 2, 3, 4, "b"]</code></pre><p>展开运算符可以轻松的将数组中的所有项放入到另一个数组中。这样简化了很多类似的操作。接下来是一个稍微复杂些的用法：</p><pre><code>    let arr = [1,2,3,4];    let [a,...b] = arr;    console.log("a:",a," b:",b);</code></pre><p>结果是：</p><pre><code>a: 1  b: (3)&nbsp;[2, 3, 4]</code></pre><p>从上述能看出，a被赋值了数字1，b被赋值了一个数组，内容是除了1之外的其他数字。展开运算符能分别赋值变量，怎么赋值随开发要求而定，这种赋值方式十分方便。</p><h3 id="展开运算符-对象"><a href="#展开运算符-对象" class="headerlink" title="展开运算符 - 对象"></a><strong>展开运算符 - 对象</strong></h3><p>类似解构赋值，展开运算符可以很方便的用于对象，可以简化对象的赋值或者获取值的操作，比如：</p><pre><code>    let obj = {        a:1,        b:2    };    let obj2 = {        ...obj,        c:3,        d:4    }    console.log(obj2);</code></pre><p>结果是：</p><pre><code>{a: 1, b: 2, c: 3, d: 4}</code></pre><p>通过上述代码，我们轻松的将obj的参数和值添加到了obj2中。但是比如下方代码：</p><pre><code>    let obj = {        a:1,        b:2    };    let obj2 = {        ...obj,        a:3,        d:4    }    console.log(obj2);</code></pre><p>结果是：</p><pre><code>{a: 3, b: 2, d: 4}</code></pre><p>可见，如果obj2中存在obj中的key-value时，则不复制进去。接下来看看另一个例子，和上述数组中类似的例子：</p><pre><code>    let obj = {        a:1,        b:2    };    let obj2 = {        ...obj,        c:3,        d:4    }    let {a,...b} = obj2;    console.log(a, b);</code></pre><p>结果是：</p><pre><code>1 {b: 2, c: 3, d: 4}</code></pre><p>结果显而易见，类似展开数组一样，a被赋值1，b被赋值成一个新对象，对象中的参数是原obj2中，除了a之外的其它的参数。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章说了下块状作用域和解构赋值。还是很好理解的，但是由于let和const是块状作用域，var则不同。所以万一需要异步操作，还是要小心赋值的问题。</p><p>至于解构赋值，对象是以变量名对应对象参数key值来解构的，变量名必须和key值相同。其它类似数组和字符串，解构时，按照索引解构，不需要特定变量名。</p><p>展开运算符的很多用法类似于解构赋值。不管是展开运算符还是解构赋值，都很大的程度上简化了一些对象，数组或类似数据结构的值的获取和赋值。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6的一些知识点整理2</title>
      <link href="2020/01/17/es6_de_yi_xie_zhi_shi_dian_zheng_li_2/"/>
      <url>2020/01/17/es6_de_yi_xie_zhi_shi_dian_zheng_li_2/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理 - 2</h1> </center><center> <h2> <font color="lightgray">异步与同步</font> </h2> </center><h3 id="异步和同步是一种消息通知机制。"><a href="#异步和同步是一种消息通知机制。" class="headerlink" title="异步和同步是一种消息通知机制。"></a><em><strong><u>异步和同步是一种消息通知机制。</u></strong></em></h3><h2 id="什么是异步？"><a href="#什么是异步？" class="headerlink" title="什么是异步？"></a>什么是异步？</h2><h3 id="异步非阻塞："><a href="#异步非阻塞：" class="headerlink" title="异步非阻塞："></a>异步非阻塞：</h3><pre><code>比如： A调用B，B处理同时，A继续执行。B处理结束，返回结果，A再用B的结果执行。A在此期间不用等B执行结束。</code></pre><h3 id="同步阻塞："><a href="#同步阻塞：" class="headerlink" title="同步阻塞："></a>同步阻塞：</h3><pre><code>比如： A调用B，B处理完后返回结果给A，A继续执行。A在此期间一直等B执行结束。正常代码的执行，是逐行执行的，就是同步机制。</code></pre><h3 id="实现异步的最基本方法：使用计时器"><a href="#实现异步的最基本方法：使用计时器" class="headerlink" title="实现异步的最基本方法：使用计时器"></a>实现异步的最基本方法：使用计时器</h3><pre><code>function move(ele, dir, dist) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    clearInterval(ele.timer);    console.log("start moving...");    ele.timer = setInterval(() =&gt; {       if (Math.abs(curPos - dist) &lt;= 0) {            clearInterval(ele.timer);            console.log("finish moving...");       } else {            curPos += speed;            ele.style[dir] = curPos + "px";       }    }, 20);    console.log("printing....");}let box = document.querySelector("#box");move(box, "left", 100);</code></pre><p>上述代码会产生下图效果：</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/code-result1.gif" alt="代码运行结果"></p><p>打印结果如下：</p><p><img src="https://blog-imgs-1253907084.cos.ap-beijing.myqcloud.com/code-result2.png" alt="代码运行打印结果"></p><p>从运行结果可以看出，printing在方块移动结束前打印了，并没有像常规的程序那样顺序执行。这就是最基本的异步的实现。</p><h3 id="异步结束完需要操作怎么办？"><a href="#异步结束完需要操作怎么办？" class="headerlink" title="异步结束完需要操作怎么办？"></a>异步结束完需要操作怎么办？</h3><p>肯定有很多解决方法，但是我认为比较好的方法是回调函数的方法，修改上述代码：</p><pre><code>function move(ele, dir, dist, callback) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    clearInterval(ele.timer);    console.log("start moving...");    ele.timer = setInterval(() =&gt; {       if (Math.abs(curPos - dist) &lt;= 0) {            clearInterval(ele.timer);            console.log("finish moving...");            callback &amp;&amp; callback(); // ===&gt;此处先判断是否存在callback，如果存在就执行       } else {            curPos += speed;            ele.style[dir] = curPos + "px";       }    }, 20);    console.log("printing....");}let box = document.querySelector("#box");move(box, "left", 100, () =&gt; {    console.log("执行回调函数");});</code></pre><p> 上述代码执行结果是：</p><pre><code>start moving...printing....finish moving...执行回调函数</code></pre><p>这样就能很好的解决异步执行之后需要用到异步的结果或者需要执行某些代码的问题。</p><h3 id="这种实现异步和回调的问题：回调地狱"><a href="#这种实现异步和回调的问题：回调地狱" class="headerlink" title="这种实现异步和回调的问题：回调地狱"></a>这种实现异步和回调的问题：回调地狱</h3><p>所谓回调地狱，就是多次回调，致使层数过深，如下：</p><pre><code>move(box, "left", 100,() =&gt; {    move(box, "top", 100,() =&gt; {        move(box, "left", -100,() =&gt; {            move(box, "top", -100,() =&gt; {                console.log("finish...");            });        });    });});</code></pre><p>上述代码层数过深，不利于代码的复用性和阅读性。</p><h2 id="回调地狱解决办法"><a href="#回调地狱解决办法" class="headerlink" title="回调地狱解决办法"></a>回调地狱解决办法</h2><p>解决办法有三种，分别是使用<strong>Promise</strong> ，使用<strong>Async和Await</strong>以及使用<strong>Generator</strong>函数。这一篇文章先讲一下Promise的使用。</p><h3 id="Promise的概念以及使用"><a href="#Promise的概念以及使用" class="headerlink" title="Promise的概念以及使用"></a>Promise的概念以及使用</h3><p><em><strong>Promise不是解决异步问题本身，而是解决异步的写法问题，使异步写法更清晰。</strong></em></p><p>先说下Promise，在MDN，Promise被如下定义：</p><pre><code>Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.[1]</code></pre><p>Promise有三个状态：<b>Pending（在等待异步流程执行完毕）；Fulfilled或者Resolved（成功）；Rejected（失败）</b>。<br>异步操作的结果决定了当前状态，其它内容无法干扰Promise状态。且，Promise如果状态改变，则不会再变，比如从pending改变到rejected，就不会再回到pending，或者再变为fulfilled。[2]</p><p>接下来展示一段Promise的简单使用：</p><pre><code>let p = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            console.log(p);            resolve();        }, 2000);     });    p.then(() =&gt; {        console.log(p);        console.log("then....");    });     </code></pre><p>then方法就相当于之前实现多次异步时候的回调函数，根据上述代码，可以发现Promise创建后传入一个函数，函数的参数是两个函数resolve和reject，分别对应着rejected和resolved（fulfilled）两个状态。现在就一目了然了，如果异步执行成功，则调用运行resolve()，反之运行reject()。上述运行结果为：</p><p>程序运行两秒后，打印如下内容：</p><pre><code>Promise&nbsp;{&lt;pending&gt;}Promise&nbsp;{&lt;resolved&gt;: undefined}then....</code></pre><p>由此可见，如果异步执行成功，调用resolve函数，则程序会向下执行到then，而且从打印的两个p我们能看出，Promise的状态从pending向resolved改变。</p><h4 id="那如何使用异步结果呢？"><a href="#那如何使用异步结果呢？" class="headerlink" title="那如何使用异步结果呢？"></a>那如何使用异步结果呢？</h4><p>很多时候，异步产生的结果，是我们后面要使用的，那么如果像上述一样用Promise来优化异步的写法，我们如何使用异步结果呢？</p><p>其实答案已经在上述代码出现了。上述代码的打印结果的第二行，Promise状态resolved后面有一个undefined。这个地方，就是用来存异步结果的。代码可以改动如下：</p><pre><code>let p = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            console.log(p);            resolve("parameters..."); // =======》这里执行resolve时候可以传入参数。        }, 2000);  }); p.then((res) =&gt; { // ======》这里能传入一个参数，比如res        console.log(p);        console.log(res);                 console.log("then...."); });</code></pre><p>运行结果如下：</p><pre><code>Promise&nbsp;{&lt;pending&gt;}Promise&nbsp;{&lt;resolved&gt;: "parameters..."}parameters...then....</code></pre><p>结合上述代码和结果，我们能看出来，通过向resolve方法传入异步结果，在调用then方法后，可以接收一个参数，这个参数就指向异步的结果。从而就能使用异步结果了。</p><p>如果想在then函数中处理reject的结果，那么也很简单，传入第二个回调函数作为参数，比如：</p><pre><code>p.then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }, (rej) =&gt; {        console.log(rej); }); </code></pre><p>一目了然，在此就不做赘述了。</p><p>但是如果存在需要链式调用then函数，每个函数中都传入两个函数来处理成功和失败的结果，有时候会比较繁琐，因此，如果所有步骤处理出现错误或者失败，都只需要返回一种信息给用户（比如网络请求错误），可以用以下办法：</p><pre><code>p.then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).then((res) =&gt; {        console.log(p);        console.log(res);        console.log("then...."); }).catch((rej) =&gt; {     console.log("fail..."); })</code></pre><p>如果想实现之前那种需要多次回调的场景也很简单，代码如下：</p><pre><code>let po = new Promise((resolve, reject) =&gt; {    resolve(1);});po.then((res) =&gt; {   console.log(res);   return 2;}).then((res) =&gt; {   console.log(res);   return 3;}).then((res) =&gt; {   console.log(res);   return 4;}).then((res) =&gt; {   console.log(res);})</code></pre><p> 运行结果是：</p><pre><code>1234</code></pre><p>很显然，then方法最后return的结果是可以被后面的then方法获取到的。但是为什么能获取呢？我们可以给调用then方法的结果赋值，打印看下。代码为：</p><pre><code>let po = new Promise((resolve, reject) =&gt; {     resolve(1); }); let pt = po.then((res) =&gt; {     console.log(res);     return "pt"; }) console.log(pt); </code></pre><p> 结果为：</p><pre><code>Promise&nbsp;{&lt;pending&gt;}__proto__: Promise[[PromiseStatus]]: "resolved"[[PromiseValue]]: "pt"1</code></pre><p>上述代码运行后先打印了最后一行的pt。因为异步的原因，然后打印了resolve传入then函数的数字1。pt的展开结果我们可以看出，then方法会给我们返回一个Promise对象，而且从上述结果看出，返回的是一个resolved状态的Promise对象。</p><p>现在我们都了解到Promise的用法了，上文中的移动方块的例子能改写为：</p><pre><code>function move(ele, dir, dist) {    let curPos = parseFloat(getComputedStyle(ele)[dir]);    let speed = (dist - curPos) /Math.abs(curPos - dist);    return new Promise((resolve, reject) =&gt; {        clearInterval(ele.timer);        ele.timer = setInterval(() =&gt; {        if (Math.abs(curPos - dist) &lt;= 0) {                clearInterval(ele.timer);                 resolve();        } else {                curPos += speed;                ele.style[dir] = curPos + "px";        }        }, 20);    })}let box = document.querySelector("#box");move(box, "left", 100).then(() =&gt; {    return move(box, "top", 100);}).then(() =&gt; {    return move(box, "left", 0);}).then(() =&gt; {    return move(box, "top", 0);})</code></pre><p>运行结果和上述结果一样。但是可读性和代码可扩展性得到了显著的提高。</p><h4 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise all方法"></a>Promise all方法</h4><p>说完Promise的使用和then还有catch常用方法，接着说下Promise的另一个常用方法 - all方法。</p><p>MDN对于all方法的说明是：</p><pre><code>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数    中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失    败原因的是第一个失败 promise 的结果。[3] </code></pre><p>简单说就是比如创建了三个不同的Promise对象，调用all方法执行三个Promise对象，如果三个都是resolved状态，则可以向下执行。</p><p>例子：</p><pre><code> let p1 = new Promise((resolve, reject) =&gt; {     console.log(1);     resolve(); });let p2 = new Promise((resolve, reject) =&gt; {     console.log(2);     resolve(); }); let p3 = new Promise((resolve, reject) =&gt; {     console.log(3);     resolve(); }); Promise.all([p1, p2, p3]).then(() =&gt;{     console.log(4); })</code></pre><p>结果：</p><pre><code>1234</code></pre><p>如果任意一个Promise对象的执行状态是rejected。则需要在then中或者或者代码最后使用catch方法捕获错误，不然会报错。</p><h3 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise race方法"></a>Promise race方法</h3><p>这个方法和all方法正好相反，all方法是全部执行结束，才执行下面的内容。race方法顾名思义，有其中一项执行结束，则开始执行下面的方法。代码如下：</p><pre><code> let p1 = new Promise((resolve, reject) =&gt; {     setTimeout(() =&gt; {        console.log(1);        resolve();     }, 2000); });let p2 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        console.log(2);        resolve();     }, 1000); }); let p3 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        console.log(3);        resolve();     }, 5000); }); Promise.race([p1, p2, p3]).then(() =&gt;{     console.log(4); }).catch(() =&gt; {     console.log("err"); });</code></pre><p>结果是：</p><pre><code>2413</code></pre><p>上面代码我们把p1的执行时间设置为2s，p2是1s，p3是5s，从结果就能看出，p1执行结束后，直接执行下面的then方法，因此打印顺序是2，4接着两个分别按照设定时间执行完毕。</p><h3 id="Async和Await写法"><a href="#Async和Await写法" class="headerlink" title="Async和Await写法"></a>Async和Await写法</h3><p>有时候用Promise的一系列方法，仍然感觉可读性一般，代码扩展性也有局限，那么这时候，可以用Async和Await结合Promise使用。示例代码如下：</p><pre><code>async function fn () {    let p1 = await new Promise((resolve) =&gt; {        console.log(1);        resolve(2);    });    let p2 = await new Promise((resolve) =&gt; {        console.log(p1);        resolve(3);    });    let p3 = await new Promise((resolve) =&gt; {        console.log(p2);        resolve(4);    });    console.log(p3);}fn();打印结果：1234</code></pre><p>Async和Await进一步简化了代码量，优化了写法，也是现今为止最常用的异步写法。<br>注意：</p><ol><li>Await 后面接一个能返回Promise对象的方法或者创建一个新Promise对象。</li><li>Await必须放在Async标示的函数当中。</li><li>如果需要捕获异常，可以用try{} catch (exception) {}，把await写入try后面的代码块中。</li><li>Async函数返回一个Promise，状态是resolved。</li><li>Await可接受非Promise作为await表达式的结果。但是不管await后面是什么，都会阻塞async函数内部代码执行，如果这时有外部代码，则先执行外部代码，之后再回到内部执行。</li><li>如果async中代码是同步代码，那就同步执行。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Promise差不多就说完了，也简单说了下Async和Await。感觉会用是最关键的。至于Generator，听说过没用过，感觉用的比较少，以后找机会再说吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p><p>[2] <a href="https://www.jianshu.com/p/1ab01ee4102a">https://www.jianshu.com/p/1ab01ee4102a</a></p><p>[3] <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6的一些知识点整理</title>
      <link href="2020/01/02/es6_de_yi_xie_zhi_shi_dian_zheng_li/"/>
      <url>2020/01/02/es6_de_yi_xie_zhi_shi_dian_zheng_li/</url>
      
        <content type="html"><![CDATA[<center> <h1>es6的一些知识点整理</h1> </center><center> <h2> <font color="lightgray">基础部分</font> </h2> </center><font size="3"><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>接触前端也很久了，当然主要都是在学校，工业级的不太多，仅仅是实习中的有限的时间接触了一些。说到前端，不得不说前端的发展历程，从最简单的类似UI的工作，到现在，各种前端框架层出不穷，前端开发也从Web开发的无足轻重，变成现在和后端一样的重要。同样由于近几年Web前端技术的发展，IOS和Android技术被挤压的很厉害，也渐渐并入前端当中。使得现在前端在Web开发中占有的比重隐隐超过后端。</p><p>以上是我个人对前端变化的理解。排除Android和IOS，Web前端技术，不论你是用什么框架，什么库，JavaScript永远是基础，也是最重要的一部分。JavaScript主要由ECMAScript（核心），DOM（文档对象模型）和BOM（浏览器对象模型）。</p><p>ES6（ECMAScript 6）是2015年推出的，也推出一段时间了，随着这几年发展，添加了很多新特性，虽然后面还有ES2017，ES2019，但是貌似普及率没有ES6高，兼容性更不要说了，ES6保证了一定的向下兼容性，后面我会总结下ES6的一些新出的基础知识点，包括新增关键词，新增概念等。</p><h2 id="ES6的兼容性"><a href="#ES6的兼容性" class="headerlink" title="ES6的兼容性"></a>ES6的兼容性</h2><p>首先先说ES6的兼容性，ES6支持绝大多数最新版本浏览器，包括Edge，Firefox 68+， Chrome 78+，Opera65+，Safari 12.1+等桌面版浏览器支持率几乎达到100%。移动版浏览器，包括IOS12+，Samsung 9+， OperaMobile 54+兼容程度也接近100%。至于IE，就基本不支持了，但是可以用代码转换。</p><h3 id="ES6兼容IE（和其它浏览器）的方法"><a href="#ES6兼容IE（和其它浏览器）的方法" class="headerlink" title="ES6兼容IE（和其它浏览器）的方法"></a>ES6兼容IE（和其它浏览器）的方法</h3><ol><li>兼容基本语法（不包括Promise之类的）</li></ol><p>在引入其它脚本前，引入browser.min.js， script标签的type设为text/babel</p><ol start="2"><li>如果使用Promise等新特性</li></ol><p>Babel默认编译转换JavaScript语句，不能转换新的API。但是可以使用Polyfill（代码填充）技术。在开发页面中引入browser-polyfill即可：</p><pre><code>&lt;script type="text/javascript" src="你的browser-polyfill路径"&gt;&lt;/script&gt;</code></pre><h2 id="let，const的使用以及它们和var的区别"><a href="#let，const的使用以及它们和var的区别" class="headerlink" title="let，const的使用以及它们和var的区别"></a>let，const的使用以及它们和var的区别</h2><p>let和const是ES6新出来的关键字，和var作用相同，用来声明变量。但是也有很多不同。如果需要考虑兼容性更多，还是推荐用var比较好。接下来说下它们的使用和区别。</p><h3 id="说let和const之前，先说说var的一些特性"><a href="#说let和const之前，先说说var的一些特性" class="headerlink" title="说let和const之前，先说说var的一些特性"></a>说let和const之前，先说说var的一些特性</h3><ul><li><p>var的作用域是全局或者整个函数块</p></li><li><p>var可以被预解析，也就是说，可以在定义前使用变量，比如：</p><p>  <code>console.log(a); var a = 10;</code>这个是不会报错的，因为var定义的a被预解析。</p></li><li><p>var定义的变量在同一作用域下能重复定义</p><p>  <code>var a = 10; console.log(a); var a = 20; console.log(20);</code> 结果是10 20</p></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li><p>let声明的变量或者语句以及表达式，作用域为块级作用域（简单粗略可以理解成是两个大括号包裹着是一个块级作用域）</p></li><li><p>同一作用域下，let不能重复声明，比如：</p><p>  <code>let a = 10; console.log(a); let a = 20;</code> 上述代码会报错，因为在同一个作用域中重复声明了a变量。</p></li><li><p>let不能被预解析，也就是：</p><p>  <code>console.log(a); let a = 10;</code>是会报错的。</p></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 就没什么可说的了，它拥有let的所有特性，并且定义的变量为常量，不可重复赋值。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>let，const和var基本介绍完了，很简单，let和const的出现，优化了声明变量，表达式等。如果不考虑兼容性，推荐使用let代替var。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.jianshu.com/p/13444c467ce2">https://www.jianshu.com/p/13444c467ce2</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla</a></li></ul></font>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECMAScript 6 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一个博客 - 新起点</title>
      <link href="2019/11/23/wo_de_di_yi_ge_bo_ke_xin_de_kai_shi/"/>
      <url>2019/11/23/wo_de_di_yi_ge_bo_ke_xin_de_kai_shi/</url>
      
        <content type="html"><![CDATA[<center> <h1>我的第一个博客</h1> </center><center> <h2> <font color="lightgray">新起点</font> </h2> </center><font size="4">您好，我是Kingsley。我于2019年5月10日毕业于南加州大学（USC）。我的专业是计算机科学。我现在仍在找美国的全职软件工程师职位。<p>在本科学习和硕士学习期间，我已经学习计算机科学超过五年了。我在英国获得了本科学位。我的大学是埃塞克斯大学。它位于英国最古老的城镇-科尔切斯特。</p><p>在这几年中。我学到了很多不同类型的技术栈。例如，Java，Spring，Python，Django，HTML，CSS，JavaScript，Vue.js，React.js，Angular，MySQL，Redis和属于其他技术领域的技术。我的知识足够广泛。但是我需要找出这些技术的未来职业方向。而且我需要深入学习相关技术。</p><p>因此，我建立并部署了此个人博客。我希望记录下我需要记住的知识点，在开发项目期间遇到的错误以及对所学技术的个人理解。</p><p>我目前的计划是修正和复习有关Java的知识，记录要点，学习期间发生的错误等。</p><p>将来，我将复习和修正越来越多我以前学过的的技术的要点。</p><p>谢谢。</p></font><p><font size="4">K.L<br></font></p>]]></content>
      
      
      <categories>
          
          <category> 一些感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 琐碎杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
